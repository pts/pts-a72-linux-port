;
; a72l.nasm: A72 assembler 1.05 ported to Linux i386, using NASM 0.98.39
; by pt@fazekas.hu at Thu Mar 28 20:29:04 CET 2024
;
; Compile with: nasm-0.98.39 -O999999999 -w+orphan-labels -f bin -o a72 a72l.nasm && chmod +x a72
; Bootstrap with: nasm-0.98.39 -O999999999 -w+orphan-labels -f bin -o a72 a72l.nasm && chmod +x a72 && ./a72l /a a72tp1.com && cmp a72.com a72tp1.com && echo OK
;
; TODO(pts): Implement buffered reads and writes for speed. How much is the speed gain? Isn't it already buffered? Currently it does an lseek(2) syscall per line.
; TODO(pts): Make the code smaller, especially call and ret, and then push and pop, and then inc and dec.
; TODO(pts): Make the code shorter by replacing e.g. `test cx, cx' with `test ecx, ecx'.
;

bits 32
cpu 386
program_base equ 600000h  ; Must be divisible by 10000h, i.e. low word must be 0.
org program_base

file_header:
Elf32_Ehdr:
	OSABI_Linux equ 3
	db 7Fh,'ELF',1,1,1,OSABI_Linux,0,0,0,0,0,0,0,0,2,0,3,0
	dd 1,_start,Elf32_Phdr-file_header,0,0
	dw Elf32_Phdr-file_header,20h,1,0,0,0
Elf32_Phdr:
	dd 1,0,program_base,0,prebss-program_base,mem_end-program_base,7,1000h

; --- .text

%macro ASSERT_NONNEGATIVE 1  ; It doesn't stop compilation on failure.
  times %1 times 0 nop
%endm

%macro LINUX_START 0
_start:  ; Entry point of the Linux i386 program. Stack: top is argc, then argv[0], argv[1] etc., then NULL, then envp[0], envp[1] etc., then NULL, then ELF aux table.
	pop eax  ; argc.
	; Now ESP points to argv[0].

	; Concatenate argv[1:] to CMDLINE_ADDR.
	;
	%define CMDLINE_ADDR BUF2
	mov edi, CMDLINE_ADDR
	pop esi  ; Discard argv[0].
.cmdline_end:  ; Last valid byte that can be overwritten with the concatenated cmdline.
.arg:	pop esi
	test esi, esi
	jz .end_of_argv
	mov al, ' '
	stosb  ; TODO(pts): Check for overflow. We have it until cmdline_end (about 90 bytes).
.char:	lodsb
	cmp al, 0
	je .arg
	stosb  ; TODO(pts): Check for overflow.
	jmp .char
.end_of_argv:
	mov al, 0DH  ; '\r'. Terminator of DOS cmdline.
	stosb  ; TODO(pts): Check for overflow.

	; Set final value of high words of all registers except for ESP.
	;
	; EDI and ESI will have their high word same as program_base; EAX,
	; EBX, ECX, EDX and EBP will have their high word set to 0. This
	; arrangement will make all of these work: string instructions (e.g.
	; LODSB), EA_DI_PLUS(x), EA_SI_PLUS(x), EA_BP_DI_PLUS(x),
	; EA_BX_DI_PLUS(x), EA_BX_SI_PLUS(x).
	mov edi, $$  ; $$ == program_base.
	mov esi, edi
	xor eax, eax
	xor ebx, ebx
	xor ecx, ecx
	xor edx, edx
	xor ebp, ebp
	; Fall through to the DOS program start.
%endm

%define EA_BX_PLUS_VAR(name) [name+ebx]
%define EA_BX_BX_PLUS_VAR(name) [name+ebx+ebx]
%define EA_DI_PLUS(x) [edi+(x)]
%define EA_SI_PLUS(x) [esi+(x)]
%define EA_BP_DI_PLUS(x) [ebp+edi+(x)]
%define EA_BX_DI_PLUS(x) [ebx+edi+(x)]
%define EA_BX_SI_PLUS(x) [ebx+esi+(x)]
%define EA_DI_AX_AX  [edi+2*eax]
%define EA32_VAR_PLUS(name, x) [name+(x)]
%define EA32_VAR_AX_AX(name) [name+eax+eax]

; For NASM.
%define PTR
;%define MM0 $MM0  ; Reserved word in NASM.
;%define INVD $INVD  ; Reserved word in NASM.
%macro DS 1
  resb %1
%endm

%macro EVEN 0
  align 2
%endm

%macro PAGE 1
%endm

%macro ORG 1
%endm

%macro XLATB 0
  ;call check_regs
  push eax
  mov ah, 0
  ;db 0d7h  ; Original XLATB instruction.
  add ax, bx
  or eax, program_base
  mov al, [eax]
  mov [esp], al
  pop eax
%endm

%macro PUSHW 1  ; It doesn't work if %1 is an immediate, but there are no such uses anyway.
  push %1
%endm

%macro CALLWW_DI 1  ; Like `CALLWW %1', but it is allowed to ruin DI.
  mov di, %1
  call edi  ; High dword of EDI is already correct (program_base>>16).
%endm

%macro CALLWWJ 1  ; Like `CALLWW %1', but shorter if only used once (and CALLWW 0 times).
  push dword %%ret  ; The function %1 will return to %%ret.
  push dword %1  ; The high word doesn't matter, we replace it below with program_base>>16.
  mov word [esp+2], program_base>>16
  ret
  %%ret:
%endm

%macro FIX_CX_AT_LOOP_TARGET 0
  movzx ecx, cx  ; Convert 0ffffffffh to 0ffffh after a LOOP instruction.
%endm

%macro CODER 2  ; Code-relative jump. Example: CODER JMP MAIN
	%1 CODE_%2
%endm

; --- Modified A72 source code follows.

	PAGE	64
	ORG	100H
LSTWID	EQU	6
MAXLEN	EQU	100H
DEFORG	EQU	100H
DEFPAG	EQU	50
%macro vars 0  ; For NASM.
PGMVAR	EQU	BUF5
USER	EQU	BUF5+80H
FUNC	EQU	USER
TXTBUF	EQU	USER+2
BINBUF	EQU	USER+4
PC	EQU	USER+6
USIZE	EQU	USER+8
VORG	EQU	USER+0AH
SYM	EQU	USER+0CH
;STK	EQU	USER+0EH  ; Old, now it needs a dword.
WADJ	EQU	USER+10H
ARGS	EQU	USER+12H
FLAGS	EQU	USER+16H
SEGPRE	EQU	USER+17H
OPCODE	EQU	USER+18H
MODRM	EQU	USER+19H
DISP	EQU	USER+1AH
IMM	EQU	USER+1CH
BINLEN	EQU	USER+1EH
TXTLEN	EQU	USER+20H
STK	EQU	USER+22H
STKH	EQU	USER+24H  ; High bits, for ESP.
OUTHDL	EQU	PGMVAR
LSTHDL	EQU	PGMVAR+2
INCLEV	EQU	PGMVAR+4
ERRORS	EQU	PGMVAR+6
TEMP	EQU	PGMVAR+8
PASS	EQU	PGMVAR+0AH
OLDPC	EQU	PGMVAR+0CH
PAGNUM	EQU	PGMVAR+0EH
LSTLIN	EQU	PGMVAR+10H
INFN	EQU	BUF4
OUTFN	EQU	BUF4+40H
LSTFN	EQU	BUF4+80H
DEFFN	EQU	BUF4+0C0H
%endm  ; For NASM.

	LINUX_START
	MOV	AH,9  ; TODO(pts): Remove these constant-setting instructions, only if not needed.
	MOV	DX,AMSG
	call dossys_printmsg  ; Print message string.
	CODER	JMP STRICT SHORT,	MAIN

CODE_ERROR:	MOV	AH,9
	call dossys_printmsg  ; Print message string.
	; !! TODO(pts): Why exit successfully here? Why not fail?
CODE_XSUCC:
	push 0
	call dossys_exit  ; Exit successfully. Doesn't return.
CODE_BAH:
	CODER	CALL,	CLOSE
CODE_OVER:
	push 1
	call dossys_exit  ; Exit with failure. Doesn't return.
CODE_MAIN:
	CODER	CALL,	INIT
	MOV	SI,CMDLINE_ADDR
	CODER	CALL,	PARAM
	CODER	JC,	ERROR
	CODER	CALL,	OPEN
	CODER	JC,	OVER
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	SI,INM
	CODER	CALL,	WRM
	MOV	SI,INFN
	CODER	CALL,	WRM
	CODER	CALL,	PRUNT
	PUSH	WORD EA32_VAR_PLUS(FUNC,0)
CODE_RUN:	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	SI,PASSM
	CODER	CALL,	WRM
	MOV	AX,EA32_VAR_PLUS(PASS,0)
	MOV	CX,10
	CODER	CALL,	WN
	CODER	CALL,	PRUNT
	INC	WORD EA32_VAR_PLUS(PASS,0)
	CODER	CALL,	PROCF
	CODER	JC,	BAH
	MOV	SI,SYMBS
	CODER	CALL,	SYMLST
	MOV	AX,EA32_VAR_PLUS(ERRORS,0)
	TEST	AX,AX
	CODER	JNZ,	HUMBUG
	MOV	AX,EA32_VAR_PLUS(FUNC,0)
	XOR	AL,AL
	XCHG	AL,AH
	MOV	EA32_VAR_PLUS(FUNC,0),AX
	TEST	AL,AL
	CODER	JNZ,	RUN
	POP	WORD EA32_VAR_PLUS(FUNC,0)
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	SI,OUTM
	CODER	CALL,	WRM
	MOV	AX,1010H
	MOV	SI,OUTFN
	CODER	CALL,	NOTHER
	TEST	WORD EA32_VAR_PLUS(FUNC,0),8080H
	CODER	JNZ,	NOWLST
	MOV	AX,4040H
	MOV	SI,LSTFN
	CODER	CALL,	NOTHER
CODE_NOWLST:
	CODER	CALL,	PRUNT
	CODER	CALL,	CLOSE
	push 0
	call dossys_exit  ; Exit successfully.
CODE_HUMBUG:
	CODER	CALL,	CLOSE
	push 2
	call dossys_exit  ; Exit with failure.
CODE_NOTHER:	TEST	EA32_VAR_PLUS(FUNC,0),AX
	CODER	JZ,	NOTH0
	CODER	CALL,	WRM
	MOV	AL,20H
	STOSB
CODE_NOTH0:	RET
CODE_PARAM:
CODE_PARAM_:
	CODER	CALL,	RFN
	CODER	JC,	PARASC
	CODER	JNZ,	PARAIN
	CODER	JMP,	PARAEN
CODE_PARAIN:	MOV	DI,INFN
	MOV	AL,EA_DI_PLUS(0)
	TEST	AL,AL
	CODER	JNZ,	PARARG
CODE_PARAWF:	MOV	DX,SI
	CODER	CALL,	WFN
	MOV	AL,EA32_VAR_PLUS(DEFFN,0)
	TEST	AL,AL
	CODER	JNZ,	PARAM_
	PUSHW	SI
	MOV	SI,DX
	MOV	DI,DEFFN
	CODER	CALL,	WFN
	MOV	SI,DEFFN
	STC
	CODER	CALL,	ADDEX
	POP	SI
	CODER	JMP,	PARAM_
CODE_PARASC:	MOV	DI,LSTFN
	MOV	DX,4201H
	and al, 0dfh  ; Convert switch character to uppercase.
	CMP	AL,4CH  ; L
	CODER	JZ,	PARAFN
	MOV	DI,OUTFN
	MOV	DX,0D0H
	CMP	AL,44H  ; D
	CODER	JZ,	PARAFN
	MOV	DX,90H
	CMP	AL,55H ; U
	CODER	JZ,	PARAFN
	MOV	DX,1201H
	CMP	AL,41H  ; A
	CODER	JZ,	PARAFN
	MOV	DI,ORIGIN
	CMP	AL,4FH  ; O
	CODER	JZ,	PARARN
CODE_PARARG:	MOV	DX,USAGE
	STC
	RET
CODE_PARAFN:	OR	EA32_VAR_PLUS(FUNC,0),DX
	CODER	CALL,	RFN
	CODER	JC,	PARASC
	CODER	JZ,	PARAEN
	CODER	JMP,	PARAWF
CODE_PARARN:
	CODER	CALL,	CC
	CODER	JZ,	PARANO
	CODER	CALL,	RNC
	CODER	JC,	PARANO
	MOV	EA_DI_PLUS(0),DX
	CODER	JMP,	PARAM_
CODE_PARANO:	MOV	DX,NOPAR
	STC
	RET
CODE_PARAEN:	MOV	AL,EA32_VAR_PLUS(DEFFN,0)
	TEST	AL,AL
	CODER	JZ,	PARANO
	MOV	AX,EA32_VAR_PLUS(FUNC,0)
	TEST	AX,AX
	CODER	JNZ,	PARAFS
	MOV	AX,5201H
	MOV	EA32_VAR_PLUS(FUNC,0),AX
CODE_PARAFS:	MOV	BP,DOTCOM
	MOV	DX,DOTASM
	MOV	DI,INFN
	TEST	AX,8080H
	CODER	JZ,	PARANS
	XCHG	BP,DX
CODE_PARANS:	MOV	SI,DEFFN
	CODER	CALL,	RFN2
	CODER	CALL,	PARAWN
	MOV	DX,BP
	MOV	DI,OUTFN
	CODER	CALL,	PARAWN
	MOV	DX,DOTLST
	MOV	DI,LSTFN
CODE_PARAWN:	PUSHW	BX
	PUSHW	SI
	PUSHW	DI
	MOV	AX,EA_DI_PLUS(0)
	TEST	AL,AL
	CODER	JNZ,	PARANX
	CODER	CALL,	WFN
CODE_PARANX:	POP	SI
	CODER	CALL,	RFN2
	CLC
	CODER	CALL,	ADDEX
	POP	SI
	POP	BX
	CLC
	RET
CODE_PROCF:	MOV	AX,EA32_VAR_PLUS(ORIGIN,0)
	MOV	EA32_VAR_PLUS(VORG,0),AX
	XOR	AX,AX
	MOV	EA32_VAR_PLUS(PC,0),AX
	MOV	EA32_VAR_PLUS(USIZE,0),AX
	MOV	EA32_VAR_PLUS(ERRORS,0),AX
	MOV	EA32_VAR_PLUS(LSTLIN,0),AX
	MOV	EA32_VAR_PLUS(BUF7,0),AX
	INC	AX
	MOV	EA32_VAR_PLUS(PAGNUM,0),AX
	CODER	CALL,	CALF
	LODSW
	MOV	BX,4200H
	XCHG	AX,BX
	XOR	CX,CX
	XOR	DX,DX
	MOV	EA_SI_PLUS(0),DX
	call dossys_seek  ; Seek in file.
CODE_PROCF1:
	CODER	CALL,	READ
	CODER	JBE,	PROCF3
	MOV	AX,EA32_VAR_PLUS(PC,0)
	MOV	EA32_VAR_PLUS(OLDPC,0),AX
	CODER	CALL,	ASM
	CODER	JC,	PROCF4
	CODER	CALL,	WLST
	CODER	JC,	PROCF2
	CODER	CALL,	WRITE
	CODER	JNC,	PROCF1
CODE_PROCF2:
	CODER	CALL,	DECF
	CODER	JNC,	PROCF2
	RET
CODE_PROCF3:
	CODER	CALL,	DECF
	CODER	JNC,	PROCF1
	CLC
	RET
CODE_PROCF4:	TEST	AL,AL
	CODER	JNS,	PROCF6
	CBW
	INC	AX
	CODER	JZ,	PROCF3
	NEG	AX
	DEC	AX
	CODER	JNZ,	PROCF5
	CODER	CALL,	WLST
CODE_PROCF5:	push eax
	CALLWW_DI EA32_VAR_AX_AX(FUNCT_ADIR)
	pop ecx  ; CX := old value of AX.
	CODER	JC,	PROCF6
	;JCXZ	PROCF1
	TEST	CX,CX
	CODER	JZ,	PROCF1
	CODER	CALL,	WLST
	CODER	JMP,	PROCF1
CODE_PROCF6:
	CODER	CALL,	WLST
	CODER	CALL,	SCREAM
	INC	WORD EA32_VAR_PLUS(ERRORS,0)
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,40H
	CODER	JZ,	PROCF1
	MOV	AH,40H
	MOV	BX,EA32_VAR_PLUS(LSTHDL,0)
	call dossys_write  ; Write to file.
	CODER	JMP,	PROCF1
CODE_WRM:	CLD
CODE_WRML:	LODSB
	STOSB
	CMP	AL,20H
	CODER	JNC,	WRML
	DEC	DI
	RET
CODE_WFN:	CLD
	PUSHW	BX
CODE_WFN1:	LODSB
	CMP	AL,61H
	CODER	JC,	WFN2
	CMP	AL,7BH
	CODER	JNC,	WFN2
	;AND	AL,0DFH  ; Don't convert to uppercase.
CODE_WFN2:	STOSB
	DEC	BX
	CODER	JNZ,	WFN1
	XOR	AL,AL
	STOSB
	POP	BX
	RET
CODE_RFN:	CLD
CODE_RFN1:	LODSB
	TEST	AL,AL
	CODER	JZ,	RFN0
	CMP	AL,0DH  ; End of cmdline.
	CODER	JZ,	RFN0
	CMP	AL,21H
	CODER	JC,	RFN1
	CMP	AL,2FH
	CODER	JZ,	RFN5
	DEC	SI
CODE_RFN2:	CLD
	MOV	BX,SI
CODE_RFN3:	LODSB
	CMP	AL,2FH
	CODER	JZ,	RFN4
	CMP	AL,21H
	CODER	JNC,	RFN3
CODE_RFN4:	DEC	SI
	SUB	SI,BX
	XCHG	SI,BX
	MOV	AL,EA_SI_PLUS(0)
	TEST	BX,BX
CODE_RFN0:	RET
CODE_RFN5:	LODSB
	;AND	AL,0DFH  ; Don't convert to lowercase.
	STC
	RET
CODE_ADDEX:	LAHF
	lea di, [bx+si]
	MOV	AL,2EH
	MOV	CX,BX
	STD
	REPNE SCASB
	CODER	JNZ,	ADDEX1
	SAHF
	CODER	JNC,	ADDEX0
	INC	DI
	CODER	JMP,	ADDEX3
CODE_ADDEX1:	SAHF
	CODER	JC,	ADDEX0
	lea di, [bx+si]
	XCHG	SI,DX
	CLD
CODE_ADDEX2:	STOSB
	LODSB
	TEST	AL,AL
	CODER	JNZ,	ADDEX2
	XCHG	SI,DX
CODE_ADDEX3:	MOV	BX,DI
	SUB	BX,SI
CODE_ADDEX0:	lea di, [bx+si]
	XOR	AL,AL
	STOSB
	RET
CODE_CALF:	MOV	AX,EA32_VAR_PLUS(INCLEV,0)
	TEST	AX,AX
	CODER	JZ,	CALF0
	CLD
	DEC	AX
	PUSHF
	XCHG	AL,AH
	SHR	EAX,2  ; EAX shorter than AX.
	MOV	SI,INCBUF
	ADD	SI,AX
	POPF
	CLC
	RET
CODE_INCF:	INC	WORD EA32_VAR_PLUS(INCLEV,0)
	MOV	DI,SI
	CODER	CALL,	CALF
	CODER	JC,	INCF0
	XCHG	DI,SI
	PUSHW	DI
	CLD
	XOR	AX,AX
	STOSW
	STOSW
	MOV	DX,DI
	CODER	CALL,	WFN
	MOV	AX,3D00H
	call dossys_open  ; Open file.
	POP	DI
	CODER	JC,	INCF0
	STOSW
	MOV	AX,EA32_VAR_PLUS(PAGLEN,0)
	MOV	EA32_VAR_PLUS(LSTLIN,0),AX
	RET
CODE_INCF0:	DEC	WORD EA32_VAR_PLUS(INCLEV,0)
CODE_CALF0:	STC
	RET
CODE_DECF:
	CODER	CALL,	CALF
	CODER	JBE,	CALF0
	MOV	AH,3EH
	MOV	BX,EA_SI_PLUS(0)
	call dossys_close  ; Close file.
	DEC	WORD EA32_VAR_PLUS(INCLEV,0)
	MOV	AX,EA32_VAR_PLUS(PAGLEN,0)
	MOV	EA32_VAR_PLUS(LSTLIN,0),AX
	CLC
	RET
CODE_WLST:	MOV EA32_VAR_PLUS(STK,0), ESP
	PUSHW	AX
	PUSHW	DX
	PUSHW	BX
	PUSHW	SI
	PUSHW	DI
	MOV	SI,EA32_VAR_PLUS(BINBUF,0)
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	BX,EA32_VAR_PLUS(BINLEN,0)
	MOV	DX,EA32_VAR_PLUS(OLDPC,0)
	ADD	DX,EA32_VAR_PLUS(VORG,0)
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	MOV	BP,DI
	TEST	AL,0C0H
	CODER	JZ,	WLSTE
	TEST	AL,40H
	CODER	JZ,	WLSTT
	CODER	CALL,	WLSTS
	CODER	CALL,	WLSTI
	MOV	BP,DI
CODE_WLSTT:	PUSHW	BX
	PUSHW	SI
	MOV	SI,EA32_VAR_PLUS(TXTBUF,0)
	MOV	BX,EA32_VAR_PLUS(TXTLEN,0)
	TEST	BX,BX
	CODER	JZ,	WLSTM
CODE_WLSTL:	LODSB
	TEST	AL,AL
	CODER	JZ,	WLSTM
	CMP	AL,0DH
	CODER	JZ,	WLSTM
	CMP	AL,0AH
	CODER	JZ,	WLSTL
	CMP	AL,9
	CODER	JNZ,	WLSTN
	MOV	AX,DI
	SUB	AX,BP
	AND	AX,7
	MOV	CX,8
	SUB	CX,AX
	MOV	AL,20H
	REP
CODE_WLSTN:	STOSB
	DEC	BX
	CODER	JNZ,	WLSTL
CODE_WLSTM:	POP	SI
	POP	BX
CODE_WLSTB:	MOV	AX,0A0DH
	STOSW
	PUSHW	DX
	PUSHW	BX
	PUSHW	SI
	CODER	CALL,	WTITLE
	MOV	DX,EA32_VAR_PLUS(TEMP,0)
	MOV	AH,40H
	MOV	BX,EA32_VAR_PLUS(LSTHDL,0)
	MOV	CX,DI
	SUB	CX,DX
	call dossys_write  ; Write to file.
	CODER	JC,	WLSTF
	POP	SI
	POP	BX
	POP	DX
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,40H
	CODER	JZ,	WLSTE
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	CODER	CALL,	WLSTS
	CODER	JNZ,	WLSTB
CODE_WLSTE:	POP	DI
	POP	SI
	POP	BX
	POP	DX
	POP	AX
	CLC
	RET
CODE_WLSTS:	MOV	AL,DH
	CODER	CALL,	HALX
	MOV	AL,DL
	CODER	CALL,	HALX
	TEST	BX,BX
	CODER	JZ,	WLSTX
	MOV	CX,BX
	CMP	CX,LSTWID
	CODER	JC,	WLSTG
	MOV	CX,LSTWID
CODE_WLSTG:	SUB	BX,CX
	CODER	JNC,	WLSTR
	XOR	BX,BX
CODE_WLSTR:	ADD	DX,CX
	MOV	AL,20H
	CLD
	STOSB
CODE_WLSTP:	FIX_CX_AT_LOOP_TARGET
	LODSB
	CODER	CALL,	HALX
	CODER	LOOP,	WLSTP
	TEST	AL,AL
CODE_WLSTX:	RET
CODE_WLSTF:	MOV	DX,LSTFN
	MOV	AL,0FH
	CODER	JMP,	SCREAM  ; Tail call.
CODE_WLSTI:	PUSHW	DX
	PUSHW	BX
	PUSHW	SI
	MOV	CX,EA32_VAR_PLUS(TEMP,0)
	SUB	CX,DI
	ADD	CX,LSTWID+LSTWID+6
	MOV	AL,20H
	REP STOSB
	TEST	BYTE EA32_VAR_PLUS(FUNC,0),80H
	CODER	JNZ,	WLSTO
	CODER	CALL,	CALF
	CODER	JC,	WLSTO
	MOV	BP,DI
	MOV	AX,EA_SI_PLUS(2)
	MOV	CX,10
	CODER	CALL,	WN
	MOV	CX,BP
	SUB	CX,DI
	ADD	CX,6
	MOV	AL,20H
	REP STOSB
CODE_WLSTO:	POP	SI
	POP	BX
	POP	DX
	RET
CODE_WTITLE:	CLD
	PUSHW	DI
	MOV	DI,BUF6
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,40H
	CODER	JZ,	WTITL5
	MOV	AX,EA32_VAR_PLUS(LSTLIN,0)
	TEST	AX,AX
	CODER	JZ,	WTITL1
	CMP	AX,EA32_VAR_PLUS(PAGLEN,0)
	CODER	JC,	WTITL5
	INC	WORD EA32_VAR_PLUS(PAGNUM,0)
	MOV	WORD EA32_VAR_PLUS(LSTLIN,0),0
	MOV	AL,0CH
	STOSB
CODE_WTITL1:	MOV	SI,AMSG
	CODER	CALL,	WRM
	MOV	AL,20H
	MOV	CX,8
	REP STOSB
	CODER	CALL,	CALF
	CODER	JC,	WTITL3
	PUSHW	DI
	ADD	SI,4
	CODER	CALL,	WRM
	POP	CX
	SUB	CX,DI
	ADD	CX,10H
	CODER	JNS,	WTITL2
	MOV	CX,1
CODE_WTITL2:	MOV	AL,20H
	REP STOSB
CODE_WTITL3:	MOV	AX,EA32_VAR_PLUS(PAGNUM,0)
	MOV	CX,10
	CODER	CALL,	WN
	MOV	AX,0A0DH
	STOSW
	MOV	SI,BUF7
	TEST	BYTE PTR EA_SI_PLUS(0),0FFH
	CODER	JZ,	WTITL4
	CODER	CALL,	WRM
	MOV	AX,0A0DH
	STOSW
CODE_WTITL4:	STOSW
	MOV	DX,BUF6
	MOV	CX,DI
	SUB	CX,DX
	MOV	BX,EA32_VAR_PLUS(LSTHDL,0)
	MOV	AH,40H
	call dossys_write  ; Write to file.
CODE_WTITL5:	INC	WORD EA32_VAR_PLUS(LSTLIN,0)
	POP	DI
	CLC
	RET
CODE_READ:	MOV EA32_VAR_PLUS(STK,0), ESP
	CODER	CALL,	CALF
	CODER	JC,	READ1
	INC	WORD EA_SI_PLUS(2)
	MOV	BX,EA_SI_PLUS(0)
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,AL
	CODER	JNS,	READ2
	MOV	AX,4200H
	XOR	CX,CX
	MOV	DX,EA32_VAR_PLUS(PC,0)
	call dossys_seek  ; Seek in file.
	CODER	JC,	READ8
	MOV	AH,3FH
	MOV	CX,8
	MOV	DX,EA32_VAR_PLUS(BINBUF,0)
	call dossys_read  ; Read from file.
	CODER	JC,	READ8
	TEST	AX,AX
	RET
CODE_READ1:	SUB	AX,AX
	RET
CODE_READ2:	MOV	AH,3FH
	MOV	CX,MAXLEN
	MOV	DX,EA32_VAR_PLUS(TXTBUF,0)
	call dossys_read  ; Read from file.
	CODER	JC,	READ8
	TEST	AX,AX
	CODER	JZ,	READ1
	MOV	CX,AX
	MOV	DX,AX
	XOR	BX,BX
	MOV	DI,EA32_VAR_PLUS(TXTBUF,0)
CODE_READ3:	FIX_CX_AT_LOOP_TARGET
	MOV	AL,EA_BX_DI_PLUS(0)
	INC	BX
	MOV	AH,0AH
	CMP	AL,0DH
	CODER	JZ,	READ6
	MOV	AH,0DH
	CMP	AL,0AH
	CODER	JZ,	READ6
	CODER	LOOP,	READ3
	CMP	BX,MAXLEN
	CODER	JNC,	READ5
	MOV	EA_BX_DI_PLUS(0),AH
	INC	BX
CODE_READ4:	MOV	EA32_VAR_PLUS(TXTLEN,0),BX
	TEST	BX,BX
	CLC
	RET
CODE_READ5:	MOV	AL,0EH
	CODER	JMP,	SCREAM  ; Tail call.
CODE_READ6:
	CODER	JCXZ,	READ7
	CMP	EA_BX_DI_PLUS(0),AH
	CODER	JNZ,	READ7
	INC	BX
CODE_READ7:	XOR	AL,AL
	MOV	EA_BX_DI_PLUS(0),AL
	MOV	AX,BX
	SUB	AX,DX
	CODER	JZ,	READ4
	CWD
	PUSHW	BX
	MOV	CX,4201H
	XCHG	AX,DX
	XCHG	AX,CX
	MOV	BX,EA_SI_PLUS(0)
	call dossys_seek  ; Seek in file.
	POP	BX
	CODER	JNC,	READ4
CODE_READ8:	MOV	DX,4
	ADD	DX,SI
	MOV	AL,0FH
	CODER	JMP,	SCREAM  ; Tail call.
CODE_WRITE:	MOV EA32_VAR_PLUS(STK,0), ESP
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,AL
	CODER	JS,	WRITE5
	TEST	AL,10H
	CODER	JZ,	WRITE0
	MOV	CX,EA32_VAR_PLUS(BINLEN,0)
	;JCXZ	WRITE5
	TEST	CX,CX
	CODER	JZ,	WRITE5
	MOV	DX,EA32_VAR_PLUS(USIZE,0)
	TEST	DX,DX
	CODER	JZ,	WRITE3
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	CX,100H
	XOR	AL,AL
	CLD
	REP STOSB
CODE_WRITE1:	PUSHW	DX
	MOV	CX,100H
	CMP	CX,DX
	CODER	JC,	WRITE2
	MOV	CX,DX
CODE_WRITE2:	PUSHW	CX
	MOV	AH,40H
	MOV	DX,EA32_VAR_PLUS(TEMP,0)
	MOV	BX,EA32_VAR_PLUS(OUTHDL,0)
	call dossys_write  ; Write to file.
	CODER	JC,	WRITE4
	POP	CX
	POP	DX
	SUB	DX,CX
	CODER	JA,	WRITE1
CODE_WRITE3:	MOV	AH,40H
	MOV	CX,EA32_VAR_PLUS(BINLEN,0)
	MOV	DX,EA32_VAR_PLUS(BINBUF,0)
	MOV	BX,EA32_VAR_PLUS(OUTHDL,0)
	call dossys_write  ; Write to file.
	CODER	JNC,	WRITE0
CODE_WRITE4:	MOV	DX,OUTFN
	MOV	AL,0FH
	CODER	JMP,	SCREAM  ; Tail call.
CODE_WRITE0:	XOR	AX,AX
	MOV	EA32_VAR_PLUS(USIZE,0),AX
CODE_WRITE5:	CLC
	RET
CODE_CLOSE:
	CODER	CALL,	CALF
	CODER	JC,	NOIN
	MOV	AH,3EH
	MOV	BX,EA_SI_PLUS(0)
	call dossys_close  ; Close file.
CODE_NOIN:	TEST	WORD EA32_VAR_PLUS(FUNC,0),4040H
	CODER	JZ,	NOLST  ; Tail call.
	TEST	WORD EA32_VAR_PLUS(FUNC,0),8080H
	CODER	JNZ,	NOLST  ; Tail call.
	MOV	AH,3EH
	MOV	BX,EA32_VAR_PLUS(LSTHDL,0)
	call dossys_close  ; Close file.
	; Fall through to tail call.
CODE_NOLST:	TEST	WORD EA32_VAR_PLUS(FUNC,0),1010H
	CODER	JZ,	NOOUT
	MOV	AH,3EH
	MOV	BX,EA32_VAR_PLUS(OUTHDL,0)
	call dossys_close  ; Close file.
CODE_NOOUT:	RET
CODE_OPEN:	MOV	SI,INFN
	CODER	CALL,	RFN2
	CODER	CALL,	INCF
	MOV	AL,0BH
	CODER	JC,	SCREAM  ; Tail call.
	TEST	WORD EA32_VAR_PLUS(FUNC,0),1010H
	CODER	JZ,	OPEN2
	MOV	AH,3CH
	XOR	CX,CX
	MOV	DX,OUTFN
	call dossys_create  ; Create file.
	CODER	JC,	OPEN4
	MOV	EA32_VAR_PLUS(OUTHDL,0),AX
CODE_OPEN2:	TEST	WORD EA32_VAR_PLUS(FUNC,0),8080H
	CODER	JNZ,	OPEN3
	TEST	WORD EA32_VAR_PLUS(FUNC,0),4040H
	CODER	JZ,	OPEN1
	MOV	AH,3CH
	XOR	CX,CX
	MOV	DX,LSTFN
	call dossys_create  ; Create file.
	CODER	JC,	OPEN5
	MOV	EA32_VAR_PLUS(LSTHDL,0),AX
CODE_OPEN1:	CLC
	RET
CODE_OPEN3:	MOV	EA32_VAR_PLUS(LSTHDL,0),AX
	CLC
	RET
CODE_OPEN5:
	CODER	CALL,	NOLST
CODE_OPEN4:	MOV	AL,0BH
CODE_SCREAM:
	CLD
	CBW
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	CX,AX
	CMP	AL,0FH
	CODER	JZ,	SCRUM
	CODER	CALL,	CALF
	CODER	JC,	SCROOM
	LODSW
	LODSW
	PUSHW	AX
	CODER	CALL,	WRM
	MOV	AL,28H
	STOSB
	POP	AX
	PUSHW	CX
	PUSHW	DX
	MOV	CX,10
	CODER	CALL,	WN
	POP	DX
	POP	CX
	MOV	AX,2029H
	STOSW
CODE_SCROOM:	CMP	CL,5
	CODER	JZ,	SCROYM
	CMP	CL,0BH
	CODER	JNZ,	SCROME
CODE_SCRUM:	MOV	SI,DX
	CODER	CALL,	WRM
	CODER	JMP,	SCROME
CODE_SCROYM:	PUSHW	CX
	MOV	AX,DX
	MOV	CX,10
	CODER	CALL,	WN
	POP	CX
CODE_SCROME:	MOV	SI,EM0
	CODER	JCXZ,	SCRAM
CODE_SCREM:  FIX_CX_AT_LOOP_TARGET
	LODSB
	TEST	AL,AL
	CODER	JNZ,	SCREM
	CODER	LOOP,	SCREM
CODE_SCRAM:
	CODER	CALL,	WRM
CODE_PRUNT:	MOV	DX,EA32_VAR_PLUS(TEMP,0)
	MOV	AX,0A0DH
	STOSW
	MOV	CX,DI
	SUB	CX,DX
	PUSHW	CX
	PUSHW	DX
	MOV	AH,40H
	MOV	BX,1
	call dossys_write  ; Write to file.
	POP	DX
	POP	CX
	STC
	RET
CODE_INIT:	MOV	AX,BUF1
	MOV	EA32_VAR_PLUS(TXTBUF,0),AX
	MOV	AX,BUF2
	MOV	EA32_VAR_PLUS(BINBUF,0),AX
	MOV	AX,BUF3
	MOV	EA32_VAR_PLUS(TEMP,0),AX
	MOV	AX,SYMBS
	MOV	EA32_VAR_PLUS(SYM,0),AX
	XOR	DI,DI
	XCHG	DI,AX
	STOSW
	MOV	EA32_VAR_PLUS(INCLEV,0),AX
	MOV	EA32_VAR_PLUS(FUNC,0),AX
	MOV	EA32_VAR_PLUS(INFN,0),AX
	MOV	EA32_VAR_PLUS(OUTFN,0),AX
	MOV	EA32_VAR_PLUS(LSTFN,0),AX
	MOV	EA32_VAR_PLUS(DEFFN,0),AX
	INC	AX
	MOV	EA32_VAR_PLUS(PASS,0),AX
	RET
FABS_P2:
CODE_P2:	XOR	AL,AL
	MOV	EA_BX_SI_PLUS(0),AL
	CODER	CALL,	INCF
CODE_P2F:	MOV	AL,0BH
	RET
FABS_P3:
CODE_P3:	MOV	AX,3D00H
	MOV	EA_BX_SI_PLUS(0),AL
	MOV	DX,SI
	call dossys_open  ; Open file.
	CODER	JC,	P2F
	MOV	BX,AX
CODE_P3L:	MOV	AH,3FH
	MOV	DX,EA32_VAR_PLUS(TEMP,0)
	MOV	CX,100H
	call dossys_read  ; Read from file.
	MOV	DX,SI
	CODER	JC,	P2F
	ADD	EA32_VAR_PLUS(PC,0),AX
	MOV	CX,AX
	CODER	JCXZ,	P3E
	TEST	BYTE EA32_VAR_PLUS(FUNC,0),10H
	CODER	JZ,	P3S
	PUSHW	AX
	PUSHW	BX
	MOV	AH,40H
	MOV	DX,EA32_VAR_PLUS(TEMP,0)
	MOV	BX,EA32_VAR_PLUS(OUTHDL,0)
	call dossys_write  ; Write to file.
	POP	BX
	POP	AX
CODE_P3S:	TEST	AX,AX
	CODER	JNZ,	P3L
CODE_P3E:	MOV	AH,3EH
	call dossys_close  ; Close file.
	RET
FABS_P4:
CODE_P4:
	CODER	CALL,	PRUNT
	CLC
	RET
FABS_P5:
CODE_P5:	CLD
	MOV	DI,BUF7
	MOV	CX,BX
	REP MOVSB
	XOR	AL,AL
	STOSB
	CLC
	RET
FABS_P6:
CODE_P6:	TEST	DX,DX
	CODER	JNZ,	P6S
	MOV	AX,EA32_VAR_PLUS(PAGLEN,0)
	MOV	EA32_VAR_PLUS(LSTLIN,0),AX
	CLC
	RET
CODE_P6S:	MOV	EA32_VAR_PLUS(PAGLEN,0),DX
	CLC
	RET
CODE_SYMLST:	TEST	BYTE EA32_VAR_PLUS(FUNC,0),40H  ; This code is part of /d (disassembly).
	CODER	JNZ,	SYMLS0
	RET
CODE_SYMLS0:	CLD
	PUSHW	SI
	CODER	CALL,	SYMSRT
	POP	SI
	LODSW
	MOV	CX,AX
	XOR	DX,DX
	MOV	AX,EA32_VAR_PLUS(PAGLEN,0)
	MOV	EA32_VAR_PLUS(LSTLIN,0),AX
	;JCXZ	SYMLS8  ; The caller ignores the flags, so we can TEST below.
	TEST	CX, CX
	CODER	JZ,	SYMLS8
CODE_cxnz:	PUSHW	CX
	PUSHW	SI
CODE_SYMLS1: FIX_CX_AT_LOOP_TARGET
	XOR	BX,BX
CODE_SYMLS2:	LODSB
	INC	BX
	TEST	AL,AL
	CODER	JNZ,	SYMLS2
	LODSW
	CMP	DX,BX
	CODER	JNC,	SYMLS3
	MOV	DX,BX
CODE_SYMLS3:
	CODER	LOOP,	SYMLS1
	POP	SI
	POP	CX
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
CODE_SYMLS4:	CLD
	PUSHW	CX
	MOV	CX,DI
CODE_SYMLS5:	LODSB
	STOSB
	TEST	AL,AL
	CODER	JNZ,	SYMLS5
	DEC	DI
	SUB	CX,DI
	ADD	CX,DX
	MOV	AL,20H
	REP STOSB
	LODSW
	PUSHW	AX
	MOV	AL,AH
	CODER	CALL,	HALX
	POP	AX
	CODER	CALL,	HALX
	MOV	AX,2020H
	STOSW
	MOV	CX,DI
	SUB	CX,EA32_VAR_PLUS(TEMP,0)
	ADD	CX,DX
	CMP	CX,4EH
	POP	CX
	CODER	JB,	SYMLS6
	CODER	CALL,	SYMLS7
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
CODE_SYMLS6:	DEC	CX
	CODER	JNZ,	SYMLS4
CODE_SYMLS7:	CMP	DI,EA32_VAR_PLUS(TEMP,0)
	CODER	JBE,	SYMLS8
	DEC	DI
	DEC	DI
	MOV	AX,0A0DH
	STOSW
	PUSHW	CX
	PUSHW	DX
	PUSHW	SI
	CODER	CALL,	WTITLE
	MOV	AH,40H
	MOV	DX,EA32_VAR_PLUS(TEMP,0)
	MOV	CX,DI
	SUB	CX,DX
	MOV	BX,EA32_VAR_PLUS(LSTHDL,0)
	call dossys_write  ; Write to file.
	POP	SI
	POP	DX
	POP	CX
CODE_SYMLS8:	RET
CODE_SYMSRT:	CLD
	LODSW
	MOV	CX,AX
	CMP	AX,2
	CODER	JNC,	SYMSR1
	RET
CODE_SYMSR1:	MOV	DX,CX
	PUSHW	CX
	PUSHW	SI
	MOV	DI,SI
CODE_SYMSR2: FIX_CX_AT_LOOP_TARGET
	LODSB
	AND	AL,7FH
	STOSB
	CODER	JNZ,	SYMSR2
	MOVSW
	CODER	LOOP,	SYMSR2
	POP	SI
	POP	CX
	PUSHW	CX
	PUSHW	SI
CODE_SYMSR3:	XOR	BX,BX
CODE_SYMSR4:	MOV	AL,EA_BX_SI_PLUS(0)
	INC	BX
	TEST	AL,AL
	CODER	JNZ,	SYMSR4
	INC	BX
	INC	BX
	lea di,[bx+si]
	XOR	BP,BP
CODE_SYMSR5:	MOV	AL,EA_BP_DI_PLUS(0)
	INC	BP
	TEST	AL,AL
	CODER	JNZ,	SYMSR5
	INC	BP
	INC	BP
	MOV	CX,BX
	CMP	CX,BP
	CODER	JNB,	SYMSR6
	MOV	CX,BP
CODE_SYMSR6:	PUSHW	SI
	PUSHW	DI
	REPE CMPSB
	POP	DI
	POP	SI
	CODER	JB,	SYMSR7
	PUSHW	SI
	PUSHW	DI
	MOV	DI,EA32_VAR_PLUS(TEMP,0)
	MOV	CX,BX
	REP MOVSB
	POP	DI
	POP	SI
	PUSHW	SI
	XCHG	SI,DI
	MOV	CX,BP
	REP MOVSB
	MOV	SI,EA32_VAR_PLUS(TEMP,0)
	MOV	CX,BX
	REP MOVSB
	POP	SI
	MOV	BX,BP
CODE_SYMSR7:	ADD	SI,BX
	DEC	DX
	CMP	DX,2
	CODER	JNC,	SYMSR3
	POP	SI
	POP	CX
	DEC	CX
	CMP	CX,2
	CODER	JNC,	SYMSR1
	RET

;	INCLUDE	GENERIC.ASM
CODE_CC:	XOR	BX,BX
CODE_CCM:	MOV	AL,EA_BX_SI_PLUS(0)
	CMP	AL,0
	CODER	JZ,	CCT
	CMP	AL,0DH
	CODER	JZ,	CCT
	CMP	AL,21H
	CODER	JC,	CCK
	CMP	AL,22H
	CODER	JZ,	CCQ
	CMP	AL,27H
	CODER	JZ,	CCQ
	CMP	AL,30H
	CODER	JC,	CCS
	CMP	AL,3AH
	CODER	JC,	CCL
	CMP	AL,3BH
	CODER	JZ,	CCT
	CMP	AL,41H
	CODER	JC,	CCS
	CMP	AL,5BH
	CODER	JC,	CCL
	CMP	AL,5FH
	CODER	JZ,	CCL
	CMP	AL,61H
	CODER	JC,	CCS
	CMP	AL,7BH
	CODER	JNC,	CCS
	AND	AL,0DFH
	MOV	EA_BX_SI_PLUS(0),AL
CODE_CCL:	INC	BX
	CODER	JMP,	CCM
CODE_CCK:	TEST	BX,BX
	CODER	JNZ,	CCT
	INC	SI
	CODER	JMP,	CCM
CODE_CCS:	TEST	BX,BX
	CODER	JZ,	CCE
CODE_CCT:	MOV	AL,EA_SI_PLUS(0)
	TEST	BX,BX
	RET
CODE_CCQ:	TEST	BX,BX
	CODER	JNZ,	CCT
CODE_CCW:	INC	BX
	CMP	AL,EA_BX_SI_PLUS(0)
	CODER	JNZ,	CCW
CODE_CCE:	INC	BX
	RET
CODE_AA:	CMP	AX,80H
	CODER	JC,	AA1
	CMP	AX,0FF80H
	RET
CODE_AA1:	CMC
	RET
CODE_SL:	CLD
	MOV	DX,EA_DI_PLUS(0)
CODE_SL1:	INC	DI
	INC	DI
	DEC	DX
	CODER	JS,	SL5
	MOV	AL,EA_BX_DI_PLUS(0)
	TEST	AL,AL
	CODER	JNZ,	SL3
	MOV	CX,BX
CODE_SL2:	DEC	BX
	CODER	JS,	SL4
	MOV	AL,EA_BX_DI_PLUS(0)
	AND	AL,7FH
	XOR	AL,EA_BX_SI_PLUS(0)
	CODER	JZ,	SL2
	MOV	BX,CX
CODE_SL3:	STC
	SBB	CX,CX
	XOR	AL,AL
	REPNE SCASB
	CODER	JZ,	SL1
	CODER	JNZ,	SL5
CODE_SL4:	MOV	BX,CX
	MOV	AX,EA_BX_DI_PLUS(1)
	ADD	SI,BX
	XOR	BX,BX
CODE_SL5:	RET
CODE_HALX:	PUSHW	AX
	SHR	AL,4
	CODER	CALL,	HALL
	POP	AX
CODE_HALL:	AND	AL,0FH
	OR	AL,30H
	CMP	AL,3AH
	CODER	JC,	HALN
	ADD	AL,7
CODE_HALN:	STOSB
	RET
CODE_RN:	CLD
	XOR	DX,DX
	CMP	CL,5
	CODER	JC,	RN1
	XOR	CL,CL
CODE_RN1:	TEST	CL,CL
	CODER	JNZ,	RN2
	SHL	DX,1
	MOV	AX,DX
	SHL	DX,2
	ADD	DX,AX
CODE_RN2:	SHL	DX,CL
	XOR	AH,AH
	LODSB
	SUB	AL,30H
	CMP	AL,0AH
	CODER	JC,	RN3
	SUB	AL,7
;	CMP	AL,10H
;	JB	RN3
;	SUB	AL,20H
	CMP	AL,0FH
	CODER	JNBE,	RN0
CODE_RN3:	ADD	DX,AX
	DEC	BX
	CODER	JNZ,	RN1
CODE_RN0:	RET
CODE_WN:	CLD
	CMP	AX,CX
	CODER	JNC,	WN1
	CMP	AX,10
	CODER	JNC,	WN1
	OR	AL,30H
	STOSB
	RET
CODE_WN1:	MOV	SI,DI
CODE_WN2:	XOR	DX,DX
	DIV	CX
	XCHG	AX,DX
	CMP	AL,10
	SBB	AL,105
	DAS
	STOSB
	XCHG	AX,DX
	TEST	AX,AX
	CODER	JNZ,	WN2
	CMP	DL,58
	CODER	JC,	WN5
	MOV	AL,48
	STOSB
CODE_WN5:	MOV	CX,DI
	SUB	CX,SI
	SHR	ECX,1  ; ECX shorter than CX.
	CODER	JZ,	WN0
	SUB	DI,CX
	ADD	SI,CX
CODE_WN4:	FIX_CX_AT_LOOP_TARGET
	DEC	SI
	MOV	AL,EA_DI_PLUS(0)
	XCHG	EA_SI_PLUS(0),AL
	STOSB
	CODER	LOOP,	WN4
CODE_WN0:	RET
CODE_LBL:
	CODER	CALL,	CC
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	AND	AL,3
	CODER	JZ,	LBL2
	MOV	DI,EA32_VAR_PLUS(SYM,0)
	CODER	CALL,	SL
	CODER	JZ,	LBL3
	MOV	CX,BX
	CLD
	REP MOVSB
	XOR	AL,AL
	STOSB
	PUSHW	DI
	MOV	DI,EA32_VAR_PLUS(SYM,0)
	INC	WORD EA_DI_PLUS(0)
	POP	DI
CODE_LBL1:	MOV	BP,DI
	MOV	AX,EA32_VAR_PLUS(PC,0)
	ADD	AX,EA32_VAR_PLUS(VORG,0)
	STOSW
	XOR	BX,BX
CODE_LBL2:	ADD	SI,BX
	CODER	CALL,	CC
	CODER	JZ,	ERR3
	CMP	AL,3AH  ; ':' after the label.
	CODER	JNZ,	LBL2S  ; Finally fixed the bug (`INC SI' below was incorrectly assumed to be 1 byte, now we use LBL2S).
	INC	SI
CODE_LBL2S:	RET
CODE_LBL3:	ADD	DI,CX
	INC	DI
	MOV	AL,2
	AND	AL,EA32_VAR_PLUS(FUNC,0)
	CODER	JNZ,	LBL1
	MOV	AL,0AH
	CODER	JMP,	FAIL
CODE_ERR3:	MOV	AL,3
	CODER	JMP,	FAIL
FABS_SETDFB:
CODE_SETDFB:	MOV	DI,EA32_VAR_PLUS(BINBUF,0)
	XOR	CX,CX
CODE_SETD1:
	CODER	CALL,	CC
	CODER	JZ,	ERR8
	CMP	AL,3FH
	CODER	JZ,	SETD5
;	TEST	CL,CL
;	JZ	SETD2
	PUSHW	AX
	XOR	AX,AX
	REP STOSB
	POP	AX
CODE_SETD2:	CMP	AL,22H
	CODER	JZ,	SETD6
	CMP	AL,27H
	CODER	JZ,	SETD6
CODE_SETD3:	PUSHW	CX
	PUSHW	DI
	CODER	CALL,	RI
	POP	DI
	POP	CX
	STOSW
	CMP	BYTE EA32_VAR_PLUS(OPCODE,0),2
	CODER	JZ,	SETD7
	CODER	JNC,	SETD4
	DEC	DI
	CODER	JMP,	SETD7
CODE_SETD4:	SHL	AX,1
	SBB	AL,AL
	PUSHW	CX
	MOV	CL,EA32_VAR_PLUS(OPCODE,0)
	SUB	CL,2
	REP STOSB
	POP	CX
	CODER	JMP,	SETD7
CODE_SETD5:	ADD	CL,EA32_VAR_PLUS(OPCODE,0)
	INC	SI
	CODER	JMP,	SETD7
CODE_SETD6:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	ADD	AL,3
	CMP	BL,AL
	CODER	JB,	SETD3
	PUSHW	CX
	MOV	CX,BX
	SUB	CX,2
	INC	SI
	REP MOVSB
	INC	SI
	POP	CX
CODE_SETD7:
	CODER	CALL,	CC
	CODER	JZ,	SETD8
	CMP	AL,2CH
	CODER	JNZ,	ERR1
	INC	SI
	CODER	JMP,	SETD1
CODE_SETD8:	ADD	EA32_VAR_PLUS(USIZE,0),CX
	ADD	EA32_VAR_PLUS(PC,0),CX
	MOV	CX,DI
	SUB	CX,EA32_VAR_PLUS(BINBUF,0)
	ADD	EA32_VAR_PLUS(BINLEN,0),CX
	ADD	EA32_VAR_PLUS(PC,0),CX
	CLC
	RET
CODE_ERR8:	MOV	AL,8
	CODER	JMP,	FAIL
CODE_ERR1:	MOV	AL,1
	CODER	JMP,	FAIL
FABS_SETINC:
CODE_SETINC:
	CODER	CALL,	CC
	CODER	JZ,	ERR8
	CMP	AL,22H
	CODER	JZ,	SETIN1
	CMP	AL,27H
	CODER	JNZ,	SETIN2
CODE_SETIN1:	INC	SI
	SUB	BX,2
	CODER	JBE,	ERR8
	CODER	JMP,	SETEND  ;; RETW  ; Bugfix: make `include "filename"' work. Surprisingly it works with comments as well.
CODE_SETIN2:	XOR	BX,BX
CODE_SETIN3:	INC	BX
	MOV	AL,EA_BX_SI_PLUS(0)
	CMP	AL,3BH
	CODER	JZ,	SETEND  ; Tail call.
	CMP	AL,21H
	CODER	JNC,	SETIN3
FABS_SETEND:
CODE_SETEND:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
CODE_FAIL:	MOV ESP, EA32_VAR_PLUS(STK,0)
	CMP	AL,5
	CODER	JNZ,	FAIL0
	MOV	DX,EA32_VAR_PLUS(IMM,0)
	TEST	DX,DX
	CODER	JNS,	FAIL1
	NOT	DX
CODE_FAIL1:	SUB	DX,7FH
CODE_FAIL0:	STC
	RET
CODE_RE:	XOR	CL,CL
	XOR	AX,AX
	MOV	EA32_VAR_PLUS(IMM,0),AX
CODE_REA:
	CODER	CALL,	CC
	CODER	JZ,	RED
	CMP	AL,2BH
	CODER	JZ,	REC
	CMP	AL,2DH
	CODER	JZ,	REB
	PUSHW	DX
	CODER	CALL,	GV
	POP	DX
	CODER	JC,	RED
	ADD	EA32_VAR_PLUS(IMM,0),AX
	CODER	JMP,	REA
CODE_REB:	XOR	CL,80H
CODE_REC:	AND	CL,0BFH
	INC	SI
	CODER	JMP,	REA
CODE_RED:	TEST	CL,40H
	CODER	JZ,	ERR8
	MOV	AX,EA32_VAR_PLUS(IMM,0)
	RET
CODE_GV:
CODE_GV_:	TEST	CL,40H
	CODER	JNZ,	GVA
	CMP	AL,DL
	CODER	JZ,	GVC
	CMP	AL,22H
	CODER	JZ,	GVQ
	CMP	AL,27H
	CODER	JZ,	GVQ
	CODER	CALL,	RNM
	CODER	JZ,	GV_
	CODER	CALL,	RNC
	CODER	JNC,	GVV
	CMP	AL,40H
	CODER	JC,	GVA
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	AND	AL,3
	CODER	JNZ,	GVL
CODE_GVC:	ADD	SI,BX
	OR	CL,1
	MOV	DX,EA32_VAR_PLUS(PC,0)
	ADD	DX,EA32_VAR_PLUS(VORG,0)
	CODER	JMP,	GVV
CODE_GVA:	STC
	RET
CODE_GVQ:	MOV	DX,EA_SI_PLUS(1)
	ADD	SI,BX
	CMP	BX,5
	CODER	JNC,	GV7
	CMP	BX,4
	CODER	JNC,	GVV
	CMP	BX,3
	CODER	JC,	GV8
	XOR	DH,DH
	CODER	JMP,	GVV
CODE_GV7:	MOV	AL,7
	CODER	JMP,	FAIL
CODE_GV8:	MOV	AL,8
	CODER	JMP,	FAIL
CODE_GVL:	PUSHW	CX
	MOV	DI,EA32_VAR_PLUS(SYM,0)
	CODER	CALL,	SL
	POP	CX
	MOV	DX,8002H
	XCHG	DX,AX
	CODER	JZ,	GVL1
	TEST	AL,EA32_VAR_PLUS(FUNC,0)
	CODER	JZ,	GVC
	MOV	AL,4
	CODER	JMP,	FAIL
CODE_GVL1:	TEST	DH,DH
	CODER	JNZ,	GVL3
	TEST	AL,EA32_VAR_PLUS(FUNC,0)
	CODER	JNZ,	GVL2
	OR	EA_DI_PLUS(0),AH
CODE_GVL2:	TEST	EA_DI_PLUS(0),AH
	CODER	JNZ,	GVV
CODE_GVL3:	OR	CL,2
CODE_GVV:	OR	CL,40H
	TEST	CL,CL
	CODER	JNS,	GVNS
	XOR	CL,80H
	NEG	DX
CODE_GVNS:	TEST	CL,10H
	CODER	JNZ,	GVWO
	TEST	CL,8
	CODER	JNZ,	GVHB
	TEST	CL,4
	CODER	JNZ,	GVLB
	CODER	JMP,	GVWO
CODE_GVHB:	TEST	CL,4
	CODER	JNZ,	GVWO
	XCHG	DL,DH
CODE_GVLB:	XOR	DH,DH
	AND	CL,0FCH
CODE_GVWO:	MOV	AX,DX
	CLC
	RET
FABS_SETORG:
CODE_SETORG:
	CODER	CALL,	RI
	MOV	EA32_VAR_PLUS(VORG,0),AX
	CLC
	RET
CODE_SETDFS:
	CODER	CALL,	RI
	ADD	EA32_VAR_PLUS(USIZE,0),AX
	ADD	EA32_VAR_PLUS(PC,0),AX
	CLC
	RET
FABS_SETEQU:
CODE_SETEQU:	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,3
	CODER	JZ,	SETEQ0
	CODER	CALL,	RI
	MOV	DI,BP
	STOSW
CODE_SETEQ0:	CLC
	RET

;	INCLUDE	8086.ASM
CODE_ASM:
	MOV EA32_VAR_PLUS(STK,0), ESP
	XOR	AX,AX
	MOV	EA32_VAR_PLUS(BINLEN,0),AX
	MOV	SI,EA32_VAR_PLUS(TXTBUF,0)
	MOV	AL,EA32_VAR_PLUS(FUNC,0)
	TEST	AL,AL
	CODER	JNS,	ASMLIN
	XOR	AX,AX
	MOV	EA32_VAR_PLUS(TXTLEN,0),AX
	MOV	SI,EA32_VAR_PLUS(BINBUF,0)
	MOV	DI,EA32_VAR_PLUS(TXTBUF,0)
	CODER	JMP,	DISASM
CODE_ASMLBL:
	CODER	CALL,	LBL
	; Fall through.
CODE_ASMLIN:
	MOV ESP, EA32_VAR_PLUS(STK,0)
	XOR	AX,AX
	MOV	DI,WADJ
	MOV	CX,7
	CLD
	REP STOSW
	CODER	CALL,	CC
	CODER	JZ,	WROUT_ASMEND  ; Reuse tail of another function.
	MOV	DI,I8086
	MOV	DX,FUNCT_IHDL
	CODER	CALL,	ASMCMD
	CODER	JZ,	WROUT  ; Tail call.
	MOV	DI,D8086
	MOV	DX,FUNCT_AHDL
	CODER	CALL,	ASMCMD
	CODER	JZ,	WROUT  ; Tail call.
	CODER	CALL,	SCREG
	CODER	JNZ,	ASMLBL
	CODER	CALL,	GSPR
	CODER	JC,	D5  ; Tail call.
	; Fall through.
FABS_G0AH:
CODE_G0AH:  ; Reimplemented, because previous implementation (`MOV AX, ASMLIN', `PUSH AX') didn't add the canary when calling CODE_WROUT.
	CODER	CALL,	WROUT
	CODER	JMP,	ASMLIN
CODE_WROUT:
	XOR	DL,DL
	XCHG	DL,EA32_VAR_PLUS(FLAGS,0)
	SHL	DL,1
	CODER	JZ,	WROUT_ASMEND
	MOV	DI,EA32_VAR_PLUS(BINBUF,0)
	ADD	DI,EA32_VAR_PLUS(BINLEN,0)
	PUSHW	SI
	PUSHW	DI
	MOV	SI,SEGPRE
	CLD
CODE_WROUT1:	LODSB
	SHL	DL,1
	CODER	JNC,	WROUT2
	STOSB
CODE_WROUT2:
	CODER	JNZ,	WROUT1
	POP	CX
	POP	SI
	XCHG	CX,DI
	SUB	CX,DI
	ADD	EA32_VAR_PLUS(BINLEN,0),CX
	ADD	EA32_VAR_PLUS(PC,0),CX
CODE_WROUT_ASMEND:
	CLC
	RET
CODE_RNM:	PUSHW	AX
	CODER	CALL,	SW
	CODER	JNZ,	RNMEND
	ADD	SI,BX
	MOV	AH,4
	CMP	AL,11H
	CODER	JZ,	RNMOFF
	CMP	AL,12H
	CODER	JZ,	RNMLO
	CMP	AL,13H
	CODER	JZ,	RNMHI
FABS_D5:
CODE_D5:	MOV	AL,0CH
	CODER	JMP,	FAIL
CODE_RNMOFF:	SHL	AH,1
CODE_RNMHI:	SHL	AH,1
CODE_RNMLO:	OR	CL,AH
	CODER	CALL,	CC
	CODER	JZ,	RNMER8
	CMP	AL,AL
CODE_RNMEND:	POP	AX
	RET
CODE_RNMER8:	MOV	AL,8
	CODER	JMP,	FAIL
CODE_BORW:
	CODER	CALL,	CC
	CODER	JZ,	RNMER8
	CODER	CALL,	SW
	CODER	JNZ,	BORW2
	CMP	AL,10H
	CODER	JZ,	RA1
	CODER	JNC,	BORW2
	ADD	SI,BX
	MOV	DI,WADJ
	CMP	AL,8
	CODER	JC,	BORW1
	INC	DI
CODE_BORW1:	XCHG	AL,EA_DI_PLUS(0)
	TEST	AL,AL
	CODER	JNZ,	RA1
	CODER	CALL,	CC
	CODER	JZ,	BORW2
	CODER	CALL,	SW
	CODER	JNZ,	BORW2
	CMP	AL,10H
	CODER	JNZ,	RA1
	ADD	SI,BX
	CODER	CALL,	CC
CODE_BORW2:	RET
CODE_RA:
CODE_RA_:	XOR	DX,DX
	XOR	CX,CX
	MOV	EA32_VAR_PLUS(WADJ,0),DX
CODE_RAS:
	CODER	CALL,	BORW
	CODER	JC,	RAIX
	CMP	AL,5BH
	CODER	JZ,	RAM
	CODER	CALL,	SCREG
	CODER	JZ,	RAR
CODE_RAL:
	CODER	CALL,	RI
	MOV	DX,304H
	XCHG	DH,CL
	AND	DH,CL
	CODER	JNZ,	RAIW
	TEST	AH,AH
	CODER	JZ,	RAIB
	CODER	CALL,	AA
	CODER	JC,	RAIW
CODE_RAIB:	DEC	CX
CODE_RAIW:	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	TEST	AL,AL
	CODER	JZ,	RAIX
	MOV	CL,2
	DEC	AX
	CODER	JZ,	RAIX
	INC	CX
CODE_RAIX:
	CODER	JMP,	WARG
CODE_RA1:	MOV	AL,1
	CODER	JMP,	FAIL
CODE_RAR:
	CODER	CALL,	GSPR
	CODER	JNC,	RAS
	MOV	DH,AL
	CMP	AL,10H
	LAHF
	CMP	AL,8
	SBB	AL,AL
	ADD	AL,2
	MOV	EA32_VAR_PLUS(WADJ,0),AL
	SAHF
	SBB	AL,AL
	ADD	AL,2
	AND	DH,7
	MOV	DL,AL
	CODER	JMP,	WARG
CODE_RAM:	INC	SI
	CODER	CALL,	BORW
	XOR	DX,DX
	XOR	CL,CL
CODE_RAD:
	CODER	CALL,	CC
	CODER	JZ,	RA8
	CMP	AL,5DH
	CODER	JZ,	RADX
	CMP	AL,2BH
	CODER	JZ,	RADP
	CMP	AL,2DH
	CODER	JZ,	RADM
	CODER	CALL,	SCREG
	CODER	JZ,	RADR
	PUSHW	DX
	MOV	DL,24H
	CODER	CALL,	GV
	POP	DX
	CODER	JC,	RA1
	ADD	EA32_VAR_PLUS(DISP,0),AX
	CODER	JMP,	RAD
CODE_RADM:	XOR	CL,80H
CODE_RADP:	AND	CL,0BFH
	INC	SI
	CODER	JMP,	RAD
CODE_RADR:	MOV	DL,1
	CMP	AL,11
	CODER	JZ,	BXD
	CMP	AL,13
	CODER	JZ,	BPD
	CMP	AL,14
	CODER	JZ,	SID
	CMP	AL,15
	CODER	JZ,	DID
	CODER	CALL,	GSPR
	CODER	JNC,	RAD
CODE_RA0D:	MOV	AL,0DH
	CODER	JMP,	FAIL
CODE_RA2:	MOV	AL,2
	CODER	JMP,	FAIL
CODE_SID:	SHL	DL,1
CODE_DID:	SHL	DL,1
CODE_BPD:	SHL	DL,1
CODE_BXD:	TEST	DH,DL
	CODER	JNZ,	RA2
	TEST	CL,80H
	CODER	JNZ,	RA2
	OR	DH,DL
	OR	CL,40H
	CODER	JMP,	RAD
CODE_RA8:	MOV	AL,8
	CODER	JMP,	FAIL
CODE_RADX:	TEST	CL,40H
	CODER	JZ,	RA8
	INC	SI
	MOV	AL,DH
	MOV	BX,RM
	XLATB
	CMP	AL,0FFH
	CODER	JZ,	RA0D
	MOV	DL,3
	MOV	DH,AL
	CMP	AL,0EH
	CODER	JZ,	RADW
	AND	CL,DL
	CODER	JNZ,	RADW
	MOV	AX,EA32_VAR_PLUS(DISP,0)
	TEST	AX,AX
	CODER	JNZ,	RADB
	CMP	DH,6
	CODER	JNZ,	WARG
CODE_RADB:	MOV	CL,8
	CODER	CALL,	AA
	CODER	JNC,	WARG
CODE_RADW:	MOV	CL,0CH
CODE_WARG:	OR	EA32_VAR_PLUS(FLAGS,0),CL
	MOV	AX,EA32_VAR_PLUS(WADJ,0)
	MOV	CL,4
	TEST	BYTE EA32_VAR_PLUS(ARGS,0),0FH
	CODER	JZ,	NARGS
	ROL	AX,CL
	ROL	DX,CL
CODE_NARGS:	OR	EA32_VAR_PLUS(ARGS,2),AX
	OR	EA32_VAR_PLUS(ARGS,0),DX
	CODER	CALL,	CC
	CODER	JNZ,	COMMA
	MOV	AX,EA32_VAR_PLUS(ARGS,0)
	MOV	CH,EA32_VAR_PLUS(ARGS,2)
	RET
CODE_COMMA:	INC	SI
	CMP	AL,3AH
	CODER	JZ,	COL
	CMP	AL,2CH
	CODER	JNZ,	GSPR1
	CODER	CALL,	CC
	CODER	JZ,	RA8
	CODER	JMP,	RA_
CODE_COL:	MOV	AL,EA32_VAR_PLUS(ARGS,0)
	CMP	AL,4
	CODER	JNZ,	GSPR1
	MOV	AX,EA32_VAR_PLUS(IMM,0)
	XCHG	AX,EA32_VAR_PLUS(DISP,0)
	MOV	EA32_VAR_PLUS(IMM,0),AX
	CODER	CALL,	RI
	MOV	DX,304H
	AND	DH,CL
	MOV	AL,2
	MOV	CL,0FH
	CODER	JMP,	WARG
CODE_GSPR1:	MOV	AL,1
	CODER	JMP,	FAIL
CODE_GSPR:	CMP	AL,10H
	CODER	JC,	GSPR0
	XCHG	AL,AH
	CODER	CALL,	CC
	XCHG	AL,AH
	CODER	JZ,	GSPR0
	CMP	AH,3AH
	CODER	JNZ,	GSPR0
	AND	AL,3
	SHL	AL,3
	OR	AL,26H
CODE_GSPR2:	INC	SI
	MOV	EA32_VAR_PLUS(SEGPRE,0),AL
	MOV	AL,EA32_VAR_PLUS(FLAGS,0)
	TEST	AL,40H
	CODER	JNZ,	GSPR1
	OR	AL,40H
	MOV	EA32_VAR_PLUS(FLAGS,0),AL
	CLC
	RET
CODE_RNC:	PUSHW	AX
	PUSHW	CX
	PUSHW	SI
	MOV	CL,5
	CMP	AL,30H
	CODER	JB,	RNC1
	CMP	AL,3AH
	CODER	JNB,	RNC1
	lea di, [bx+si]
	DEC	BX
	MOV	AL,EA_BX_SI_PLUS(0)
	CMP	AL,42H
	CODER	JE,	RNC2
	CMP	AL,48H
	CODER	JE,	RNC16
	CMP	AL,4FH
	CODER	JE,	RNC8
	CMP	AL,51H
	CODER	JE,	RNC8;RNC4
	INC	BX
	CMP	AL,30H
	CODER	JB,	RNC1
	CMP	AL,3AH
	CODER	JB,	RNC10
CODE_RNC1:	POP	SI
	POP	CX
	POP	AX
CODE_GSPR0:	STC
	RET
CODE_RNC2:	DEC	CX
CODE_RNC4:	DEC	CX
CODE_RNC8:	DEC	CX
CODE_RNC16:	DEC	CX
CODE_RNC10:
	CODER	CALL,	RN
	CODER	JNZ,	RNC1
	POP	SI
	MOV	SI,DI
CODE_RNC0:	POP	CX
	POP	AX
	CLC
	RET
CODE_SCREG:	PUSHW	CX
	CMP	BX,2
	CODER	JNZ,	SCREG0
	MOV	AX,EA_SI_PLUS(0)
	MOV	DI,REGS
	MOV	CX,14H
	CLD
	REPNE SCASW
	CODER	JNZ,	SCREG0
	ADD	SI,BX
	MOV	AL,13H
	SUB	AL,CL
	XOR	BX,BX
CODE_SCREG0:	POP	CX
	RET
CODE_SW:	PUSHW	CX
	PUSHW	DX
	PUSHW	BX
	PUSHW	SI
	MOV	DI,D8086
	CODER	CALL,	SL
	POP	SI
	POP	BX
	POP	DX
	POP	CX
	CODER	JNZ,	SW1
	CMP	AH,5
	CODER	JZ,	SW2
CODE_SW1:	MOV	AX,EA_SI_PLUS(0)
CODE_SW2:	RET
; Input: DX: function call table pointer (FUNCT_IHDL or FUNCT_AHDL).
CODE_ASMCMD:	XOR	BYTE EA32_VAR_PLUS(FLAGS,0),20H
	PUSHW	DX
	CODER	CALL,	SL
	POP	DI
	CODER	JNZ,	SW2
	XCHG	AL,EA32_VAR_PLUS(OPCODE,0)
	XCHG	AL,AH
	CALLWW_DI EA_DI_AX_AX  ; May ruin AX.  ; This won't work if code for FUNCT_IHDL or FUNCT_AHDL isn't in the program_base 64KiB.
	CODER	CALL,	CC
	CODER	JZ,	SW2
	MOV	AL,9
	CODER	JMP,	FAIL
CODE_WA:	PUSHW	AX
	PUSHW	CX
	AND	AL,0F0H
	MOV	AH,CH
	XCHG	AL,CH
	SHR	AH,CL
	AND	AX,0F0FH
	CODER	JZ,	WAZ
	TEST	AL,AL
	CODER	JZ,	WALZ
	TEST	AH,AH
	CODER	JZ,	WAHZ
	CMP	AL,AH
	CODER	JZ,	WAHZ
	CMP	CH,40H
	CODER	JZ,	WAHZ
CODE_WA6:	MOV	AL,6
	CODER	JMP,	FAIL
CODE_WA0:	XOR	AL,AL
	CODER	JMP,	FAIL
CODE_WALZ:	MOV	AL,AH
CODE_WAHZ:	CMP	AL,3
	CODER	JNC,	WA0
	DEC	AX
CODE_WAZ:	MOV	EA32_VAR_PLUS(WADJ,0),AL
	TEST	BYTE EA32_VAR_PLUS(FLAGS,0),2
	CODER	JZ,	WAE
	TEST	AL,AL
	CODER	JZ,	WAB
	CMP	AH,1
	CODER	JZ,	WAB
	OR	BYTE EA32_VAR_PLUS(FLAGS,0),1
CODE_WAE:	POP	CX
	POP	AX
	RET
CODE_WAB:	AND	BYTE EA32_VAR_PLUS(FLAGS,0),0FEH
	TEST	BYTE EA32_VAR_PLUS(FUNC,0),1
	CODER	JNZ,	WAE
	MOV	AX,EA32_VAR_PLUS(IMM,0)
	TEST	AH,AH
	CODER	JZ,	WAE
	CODER	CALL,	AA
	CODER	JNC,	WAE
CODE_WA7:	MOV	AL,7
	CODER	JMP,	FAIL
CODE_MMODRM:	OR	BYTE EA32_VAR_PLUS(FLAGS,0),10H
	MOV	AX,EA32_VAR_PLUS(ARGS,0)
	MOV	CL,4
	CMP	AL,11H
	CODER	JZ,	MREGR
	CMP	AL,12H
	CODER	JZ,	MREGL
	CMP	AL,13H
	CODER	JZ,	MMEMR
	CMP	AL,21H
	CODER	JZ,	MREGR
	CMP	AL,23H
	CODER	JZ,	MMEMR
	CMP	AL,31H
	CODER	JZ,	MMEML
	CMP	AL,32H
	CODER	JZ,	MMEML
	AND	AX,0F0FH
	CMP	AL,1
	CODER	JZ,	MREGR
	CMP	AL,3
	CODER	JZ,	MMEMR
	MOV	AX,EA32_VAR_PLUS(ARGS,0)
	ROR	AX,CL
	AND	AX,0F0FH
	CMP	AL,1
	CODER	JZ,	MREGR
	CMP	AL,3
	CODER	JZ,	MMEMR
	RET
CODE_MMEML:	ROR	AH,CL
CODE_MMEMR:	MOV	AL,AH
	PUSHW	AX
	AND	AX,7007H
	ROR	AH,1
	OR	AL,AH
	OR	EA32_VAR_PLUS(MODRM,0),AL
	POP	AX
	AND	AL,8
	CODER	JNZ,	MM0
	MOV	AL,EA32_VAR_PLUS(FLAGS,0)
	AND	AL,0CH
	CODER	JZ,	MM0
	MOV	AH,40H
	AND	AL,4
	CODER	JZ,	MM8
	SHL	AH,1
	CODER	JMP,	MM8
CODE_MREGL:	ROR	AH,CL
CODE_MREGR:	MOV	AL,AH
	ROR	AH,1
	AND	AX,3807H
	OR	AL,0C0H
	OR	AH,AL
CODE_MM8:	OR	EA32_VAR_PLUS(MODRM,0),AH
CODE_MM0:	RET
FABS_G2:
CODE_G2:
	CODER	CALL,	RA
	PUSHW	AX
	AND	AX,0F0FH
	MOV	EA32_VAR_PLUS(ARGS,0),AX
	MOV	AL,0D0H
	XCHG	AL,EA32_VAR_PLUS(OPCODE,0)
	MOV	EA32_VAR_PLUS(MODRM,0),AL
	MOV	AL,CH
	AND	AL,0FH
	CODER	JZ,	G2B
	DEC	AX
	CODER	JZ,	G2B
	OR	EA32_VAR_PLUS(OPCODE,0),AL
CODE_G2B:	POP	AX
	AND	AX,0F0F0H
	CODER	JZ,	G2N
	CMP	AX,1010H
	CODER	JZ,	G2CL
	CMP	AL,40H
	CODER	JNZ,	G2F
	MOV	AX,EA32_VAR_PLUS(IMM,0)
	CMP	AX,1
	CODER	JZ,	G2N
CODE_G2F:	MOV	AL,1
	CODER	JMP,	FAIL
CODE_G2CL:	OR	BYTE EA32_VAR_PLUS(OPCODE,0),2
CODE_G2N:	AND	BYTE EA32_VAR_PLUS(FLAGS,0),0FCH
	CODER	JMP,	MMODRM
FABS_G1:
CODE_G1:
	CODER	CALL,	RA
	CODER	CALL,	WA
	MOV	CH,4
	AND	AH,0FH
	CMP	AX,41H
	CODER	JZ,	G1AI
	CMP	AL,11H
	CODER	JZ,	G1MR
	CMP	AL,13H
	CODER	JZ,	G1MR
	CMP	AL,31H
	CODER	JZ,	G1RM
	CMP	AL,41H
	CODER	JZ,	G1MI
	CMP	AL,43H
	CODER	JNZ,	ERR0
CODE_G1MI:	MOV	AL,80H
	XCHG	AL,EA32_VAR_PLUS(OPCODE,0)
	OR	EA32_VAR_PLUS(MODRM,0),AL
	MOV	AX,EA32_VAR_PLUS(IMM,0)
	CODER	CALL,	AA
	CODER	JC,	G1MR
	MOV	AL,EA32_VAR_PLUS(ARGS,2)
	CMP	AL,22H
	CODER	JZ,	G1MR
	AND	BYTE EA32_VAR_PLUS(FLAGS,0),0FEH
	TEST	BYTE EA32_VAR_PLUS(WADJ,0),0FFH
	CODER	JZ,	G1MR
CODE_G1RM:	OR	BYTE EA32_VAR_PLUS(OPCODE,0),2
CODE_G1MR:	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	OR	EA32_VAR_PLUS(OPCODE,0),AL
	CODER	JMP,	MMODRM
CODE_G1AI:	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	OR	AL,CH
	OR	EA32_VAR_PLUS(OPCODE,0),AL
	RET
CODE_ERR0:	MOV	AL,0
	CODER	JMP,	FAIL
FABS_G3:
CODE_G3:
	CODER	CALL,	RA
	CODER	CALL,	WA
	MOV	CH,0A8H
	AND	AH,0FH
	CMP	AX,41H
	CODER	JZ,	G1AI
	MOV	CH,0F6H
	CMP	AL,1
	CODER	JZ,	G3R
	CMP	AL,3
	CODER	JZ,	G3R
	CMP	AL,41H
	CODER	JZ,	G3R
	CMP	AL,43H
	CODER	JZ,	G3R
	MOV	CH,84H
	CMP	AL,11H
	CODER	JZ,	G3R
	CMP	AL,13H
	CODER	JZ,	G3R
	CMP	AL,31H
	CODER	JNZ,	ERR0
CODE_G3R:	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	OR	AL,CH
	XCHG	AL,EA32_VAR_PLUS(OPCODE,0)
	OR	EA32_VAR_PLUS(MODRM,0),AL
	CODER	JMP,	MMODRM
FABS_G4:
CODE_G4:
	CODER	CALL,	RA
	CODER	CALL,	WA
	CMP	AL,2
	CODER	JZ,	G4S
	CMP	AL,3
	CODER	JZ,	G4M
	CMP	AL,1
	CODER	JNZ,	ERR0
	CMP	CH,2
	CODER	JC,	G4M
	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	AND	AL,18H
	OR	AL,40H
	OR	AL,AH
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
	RET
CODE_G4M:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	CMP	AL,38H
	MOV	AX,8FH
	CODER	JZ,	G4P
	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	TEST	CH,CH
	CODER	JNZ,	G4W
	INC	AX
CODE_G4W:	OR	AL,0FEH
	MOV	AH,EA32_VAR_PLUS(OPCODE,0)
CODE_G4P:	MOV	EA32_VAR_PLUS(OPCODE,0),AX
	CODER	JMP,	MMODRM
CODE_G4S:	DEC	CX
	SHL	AH,CL
	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	SHR	AL,CL
	AND	AL,1
	OR	AL,AH
	OR	AL,6
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
	RET
FABS_G6:
CODE_G6:
	CODER	CALL,	RA
	CMP	AL,1
	CODER	JZ,	G6R
	CMP	AL,4
	CODER	JZ,	G6I
	CMP	AL,44H
	CODER	JZ,	G6IF
	CMP	AL,3
	CODER	JNZ,	G6F0
CODE_G6R:	MOV	AL,EA32_VAR_PLUS(ARGS,3)
	CMP	AL,8
	CODER	JZ,	G6F0
	CMP	AL,9
	CODER	JZ,	G6RN
	CMP	AL,0AH
	CODER	JZ,	G6RF
	MOV	AL,CH
	CMP	AL,0
	CODER	JZ,	G6RN
	CMP	AL,2
	CODER	JZ,	G6RN
	CMP	AL,3
	CODER	JNZ,	G6F0
CODE_G6RF:	OR	BYTE EA32_VAR_PLUS(MODRM,0),8
CODE_G6RN:	MOV	CL,0FFH
	XCHG	CL,EA32_VAR_PLUS(OPCODE,0)
	MOV	AL,10H
	SHL	AL,CL
	OR	EA32_VAR_PLUS(MODRM,0),AL
	CODER	JMP,	MMODRM
CODE_G6I:	MOV	AL,EA32_VAR_PLUS(ARGS,3)
	CMP	AL,0
	CODER	JZ,	G6IN
	CMP	AL,8
	CODER	JZ,	G6IS
	CMP	AL,9
	CODER	JZ,	G6IN
	CMP	AL,0AH
	CODER	JNZ,	G6F0
CODE_G6IF:	MOV	AX,EA32_VAR_PLUS(IMM,0)
	XCHG	AX,EA32_VAR_PLUS(DISP,0)
	MOV	EA32_VAR_PLUS(IMM,0),AX
	OR	BYTE EA32_VAR_PLUS(FLAGS,0),0FH
	MOV	AX,9AEAH
	XCHG	AH,EA32_VAR_PLUS(OPCODE,0)
	TEST	AH,AH
	CODER	JZ,	G5X
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
CODE_G5X:	RET
CODE_G6IS:	MOV	AL,0EBH
	XCHG	AL,EA32_VAR_PLUS(OPCODE,0)
	TEST	AL,AL
	CODER	JNZ,	G5S
CODE_G6F0:	MOV	AL,0
	CODER	JMP,	FAIL
CODE_G6IN:	MOV	AX,EA32_VAR_PLUS(IMM,0)
	SUB	AX,EA32_VAR_PLUS(PC,0)
	SUB	AX,EA32_VAR_PLUS(VORG,0)
	SUB	AX,3
	MOV	EA32_VAR_PLUS(IMM,0),AX
	OR	BYTE EA32_VAR_PLUS(FLAGS,0),3
	OR	BYTE EA32_VAR_PLUS(OPCODE,0),0E8H
	RET
FABS_G5:
CODE_G5:
	CODER	CALL,	RA
CODE_G5S:	AND	BYTE EA32_VAR_PLUS(FLAGS,0),0FEH
	MOV	AX,EA32_VAR_PLUS(IMM,0)
	SUB	AX,EA32_VAR_PLUS(PC,0)
	SUB	AX,EA32_VAR_PLUS(VORG,0)
	SUB	AX,2
	MOV	EA32_VAR_PLUS(IMM,0),AX
	TEST	BYTE EA32_VAR_PLUS(FUNC,0),2
	CODER	JZ,	G5X
	CODER	CALL,	AA
	CODER	JNC,	G5X
	MOV	AL,5
	CODER	JMP,	FAIL
FABS_G8:
CODE_G8:
	CODER	CALL,	RA
	CMP	AL,31H
	CODER	JNZ,	G6F0
	CODER	JMP,	MMODRM
FABS_G9:
CODE_G9:
	CODER	CALL,	RA
	CODER	CALL,	WA
	XOR	CH,CH
	CMP	AX,0E031H
	CODER	JZ,	G9A
	CMP	AX,0E13H
	CODER	JZ,	G9A2
	CMP	AL,11H
	CODER	JZ,	G9MR
	CMP	AL,13H
	CODER	JZ,	G9MR
	CMP	AL,21H
	CODER	JZ,	G9SR
	CMP	AL,23H
	CODER	JZ,	G9SR
	CMP	AL,43H
	CODER	JZ,	G9MI
	MOV	CH,2
	CMP	AL,12H
	CODER	JZ,	G9SR
	CMP	AL,31H
	CODER	JZ,	G9MR
	CMP	AL,32H
	CODER	JZ,	G9SR
	MOV	CH,0B0H
	CMP	AL,41H
	CODER	JNZ,	G9F0
	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	DEC	CX
	SHL	AL,CL
	CODER	JMP,	G9S
CODE_G9A2:	MOV	CH,2
CODE_G9A:	MOV	AX,EA32_VAR_PLUS(DISP,0)
	MOV	EA32_VAR_PLUS(IMM,0),AX
	MOV	AL,EA32_VAR_PLUS(FLAGS,0)
	AND	AX,0E3H
	OR	AL,3
	MOV	EA32_VAR_PLUS(FLAGS,0),AL
	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	OR	AL,0A0H
CODE_G9S:	OR	AL,AH
	OR	AL,CH
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
	RET
CODE_G9SR:	MOV	AL,8CH
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
	CODER	JMP,	G9M
CODE_G9MI:	MOV	AL,0C6H
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
CODE_G9MR:	MOV	AL,EA32_VAR_PLUS(WADJ,0)
CODE_G9M:	OR	AL,CH
	OR	EA32_VAR_PLUS(OPCODE,0),AL
	CODER	JMP,	MMODRM
FABS_G0EH:
CODE_G0EH:
	CODER	CALL,	RA
	CMP	AL,14H
	CODER	JZ,	G0EHRM
	CMP	AL,34H
	CODER	JNZ,	G9F0
CODE_G0EHRM:	MOV	AX,EA32_VAR_PLUS(IMM,0)
	CMP	AX,3FH
	CODER	JA,	G0CHF
	MOV	AH,AL
	DEC	CX
	ROR	AL,CL
	AND	AX,707H
	ROL	AH,CL
	OR	EA32_VAR_PLUS(OPCODE,0),AX
	AND	BYTE EA32_VAR_PLUS(FLAGS,0),0FCH
	CODER	JMP,	MMODRM
CODE_G9F0:	MOV	AL,0
	CODER	JMP,	FAIL
FABS_G7:
CODE_G7:
	CODER	CALL,	CC
	CODER	JNZ,	G7A
	MOV	AX,0AH
	MOV	EA32_VAR_PLUS(IMM,0),AX
CODE_G7B:	OR	BYTE EA32_VAR_PLUS(FLAGS,0),2
	RET
CODE_G7A:
	CODER	CALL,	RI
	TEST	AH,AH
	CODER	JZ,	G7B
CODE_G0CHF:	MOV	AL,7
	CODER	JMP,	FAIL
FABS_G0CH:
CODE_G0CH:
	CODER	CALL,	RE
	CMP	AX,3
	CODER	JZ,	G0CH3
	TEST	AH,AH
	CODER	JNZ,	G0CHF
	OR	BYTE EA32_VAR_PLUS(FLAGS,0),2
	RET
CODE_G0CH3:	DEC	BYTE EA32_VAR_PLUS(OPCODE,0)
	RET
FABS_G0DH:
CODE_G0DH:
	CODER	CALL,	RA
	AND	BYTE EA32_VAR_PLUS(FLAGS,0),0FEH
	CMP	AL,41H
	CODER	JZ,	G0DHI
	CMP	AL,14H
	CODER	JZ,	G0DHO
	OR	BYTE EA32_VAR_PLUS(OPCODE,0),8
	CMP	AX,2011H
	CODER	JZ,	G0DHI
	CMP	AX,211H
	CODER	JNZ,	G9F0
CODE_G0DHO:	SHR	CH,CL
CODE_G0DHI:	MOV	AL,CH
	AND	AL,0FH
	CMP	AL,2
	CODER	JC,	G0DH0
	INC	BYTE EA32_VAR_PLUS(OPCODE,0)
CODE_G0DH0:	RET
FABS_G0FH:
CODE_G0FH:
	CODER	CALL,	RA
	CODER	CALL,	WA
	CMP	AL,13H
	CODER	JZ,	G0FHM
	CMP	AL,31H
	CODER	JZ,	G0FHM
	CMP	AL,11H
	CODER	JNZ,	G9F0
	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	TEST	AL,0FFH
	CODER	JZ,	G0FHM
	MOV	AL,AH
	TEST	AL,0FH
	CODER	JZ,	G0FHAR
	TEST	AL,0F0H
	CODER	JZ,	G0FHRA
CODE_G0FHM:	MOV	AL,EA32_VAR_PLUS(WADJ,0)
	OR	AL,86H
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
	CODER	JMP,	MMODRM
CODE_G0FHAR:	SHR	AL,CL
CODE_G0FHRA:	OR	AL,90H
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
FABS_G0BH:
CODE_G0BH:
	CODER	CALL,	CC
	CODER	JZ,	G0  ; Tail call.
	CODER	CALL,	RA
	CMP	AL,4
	CODER	JNZ,	G0BH1
	OR	BYTE EA32_VAR_PLUS(FLAGS,0),3
	DEC	BYTE EA32_VAR_PLUS(OPCODE,0)
CODE_G0BH1:	MOV	AL,EA32_VAR_PLUS(ARGS,3)
	CMP	AL,9
	CODER	JZ,	G0  ; Tail call.
	CMP	AL,10
	CODER	JNZ,	G0  ; Tail call.
CODE_G0BH2:	OR	BYTE EA32_VAR_PLUS(OPCODE,0),8
FABS_G0:
CODE_G0:	RET
FABS_D0:
CODE_D0:	MOV	AX,EA32_VAR_PLUS(PC,0)
	SHR	AL,1
	SBB	AL,AL
	AND	AL,20H
	MOV	EA32_VAR_PLUS(FLAGS,0),AL
	XOR	CX,CX
	RET
FABS_D6:
CODE_D6:
	CODER	CALL,	CC
	CMP	AL,3AH
	CODER	JZ,	D6SEG
	CODER	JMP,	SETDFS
CODE_D6SEG:	MOV	AL,3EH
	CODER	CALL,	GSPR2
	XOR	CX,CX
	CODER	JMP,	G0AH  ; Tail call.
FABS_D8:
CODE_D8:	MOV	DI,EA32_VAR_PLUS(TEMP,0)
CODE_D8L:
	CODER	CALL,	CC
	CODER	JZ,	D9X	;D8P
	CMP	AL,27H
	CODER	JZ,	D8Q
	CMP	AL,22H
	CODER	JZ,	D8Q
	CMP	AL,2CH
	CODER	JZ,	D8C
	PUSH	DWORD EA32_VAR_PLUS(STK,0)
	PUSHW	DI
	CODER	CALL,	D8F
	POP	DI
	POP	DWORD EA32_VAR_PLUS(STK,0)
	CODER	JC,	D9X	;D8P
	PUSHW	SI
	MOV	CX,10
	CODER	CALL,	WN
	POP	SI
	CODER	JMP,	D8L
CODE_D8Q:	INC	SI
	SUB	BX,2
	CODER	JBE,	D9X	;D8P
	CLD
	MOV	CX,BX
	REP MOVSB
CODE_D8C:	INC	SI
	CODER	JMP,	D8L
;D8P:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
;	MOV	SI,EA32_VAR_PLUS(TEMP,0)
;	MOV	BX,DI
;	SUB	BX,SI
;	JMP	FAIL
CODE_D8F:	MOV EA32_VAR_PLUS(STK,0), ESP
CODE_RI:	MOV	DL,24H
	CODER	JMP,	RE  ; Tail call.
FABS_D9:
CODE_D9:	XOR	DX,DX
	CODER	CALL,	CC
	CODER	JZ,	D9X
	CODER	CALL,	RI
	MOV	DX,AX
CODE_D9X:
	CODER	JMP,	SETEND  ; Tail call.
CODE_DISASM:	CLD
	PUSHW	SI
	LODSB
	XOR	AH,AH
	MOV	EA32_VAR_PLUS(OPCODE,0),AL
	MOV	BX,AX
	AND	AL,1
	SHL	AL,4
	MOV	EA32_VAR_PLUS(WADJ,0),AX
	MOV	AL,EA_BX_PLUS_VAR(BIN86)
	MOV	CX,AX
	MOV	AL,EA_BX_PLUS_VAR(HDL86)
	MOV	BX,AX
	CMP	CL,7FH
	CODER	JNC,	DISAS1
	MOV	DX,I8086+2
	CODER	CALL,	WMN
	MOV	AL,9
	STOSB
CODE_DISAS1:	; We mustn't ruin SI or DI, because functions in FUNCT_DHDL rely on its previous value. But the value of BX doesn't matter.
	CALLWWJ	EA_BX_BX_PLUS_VAR(FUNCT_DHDL)
	MOV	AX,0A0DH
	STOSW
	MOV	CX,SI
	POP	SI
	SUB	CX,SI
	MOV	EA32_VAR_PLUS(BINLEN,0),CX
	ADD	EA32_VAR_PLUS(PC,0),CX
	MOV	AX,DI
	SUB	AX,EA32_VAR_PLUS(TXTBUF,0)
	MOV	EA32_VAR_PLUS(TXTLEN,0),AX
	CLC
	RET
CODE_WMN:	CLD
	PUSHW	SI
	MOV	SI,DX
	XOR	CH,CH
	CODER	JCXZ,	WMN2
CODE_WMN1:	FIX_CX_AT_LOOP_TARGET
	LODSB
	TEST	AL,AL
	CODER	JNZ,	WMN1
	LODSW
	CODER	LOOP,	WMN1
CODE_WMN2:	LODSB
	STOSB
	TEST	AL,AL
	CODER	JNZ,	WMN2
	DEC	DI
	POP	SI
	RET
FABS_RELBD:
CODE_RELBD:	CMP	BYTE EA32_VAR_PLUS(OPCODE,0),0EBH
	CODER	JNZ,	NOTJMP
	MOV	CL,20
	MOV	DX,D8086+2
	CODER	CALL,	WMN
	MOV	AL,20H
	STOSB
CODE_NOTJMP:	LODSB
	CBW
	ADD	AX,2
	ADD	AX,EA32_VAR_PLUS(PC,0)
	ADD	AX,EA32_VAR_PLUS(VORG,0)
	CODER	JMP,	WHA  ; Tail call.
;NOTJMP:	MOV	AX,2B24H
;	STOSW
;	LODSB
;	ADD	AL,2
;	JNS	RELBNM
;	DEC	DI
;RELBNM:	CBW
CODE_WHAS:	TEST	AX,AX
	CODER	JNS,	WHA  ; Tail call.
	NEG	AX
	MOV	BYTE EA_DI_PLUS(0),2DH
	INC	DI
CODE_WHA:	PUSHW	SI
	PUSHW	AX
	MOV	CX,16
	CODER	CALL,	WN
	POP	AX
	POP	SI
	CMP	AX,9
	CODER	JNA,	WHA0
	MOV	AL,48H
	STOSB
CODE_WHA0:	RET
FABS_MACCD:
CODE_MACCD:	MOV	AL,6
	CODER	JMP,	MRD1
FABS_MRD:
CODE_MRD:	LODSB
CODE_MRD1:	PUSHW	AX
	CODER	CALL,	WDISP
	MOV	AL,2CH
	STOSB
	POP	AX
CODE_WREG:	CLD
	PUSHW	SI
	MOV	SI,AX
	SHR	SI,2
	AND	SI,0EH
	CODER	JMP,	WDISP1
CODE_WPTR:	LODSB
	CMP	AL,0C0H
	CODER	JNC,	WDISP  ; Tail call.
	MOV	DX,D8086+2
	PUSHW	AX
	MOV	CL,22
	TEST	BYTE EA32_VAR_PLUS(WADJ,0),0FFH
	CODER	JNZ,	WSELF
	XOR	CL,CL
CODE_WSELF:
	CODER	CALL,	WMN
	MOV	AL,20H
	STOSB
	MOV	CL,19
	CODER	CALL,	WMN
	MOV	AL,20H
	STOSB
	POP	AX
CODE_WDISP:	PUSHW	SI
	MOV	SI,AX
	AND	SI,7
	CMP	AL,0C0H
	CODER	JC,	WDD
	SHL	SI,1
CODE_WDISP1:	ADD	SI,REGS
	ADD	SI,EA32_VAR_PLUS(WADJ,0)
	MOVSW
	POP	SI
	RET
CODE_WDD:	PUSHW	AX
	MOV	AL,5BH
	STOSB
	POP	AX
	AND	AL,0C7H
	CMP	AL,6
	CODER	JNZ,	WDC
	POP	SI
	LODSW
	CODER	CALL,	WHA
	MOV	AL,5DH
	STOSB
	RET
CODE_WDC:	PUSHW	AX
	ADD	SI,_DISP
	MOV	DL,EA_SI_PLUS(0)
	MOV	AL,2BH
	MOV	CL,4
CODE_WDL:	MOV	SI,DX
	AND	SI,0FH
	ADD	SI,REGS+16
	MOVSW
	STOSB
	SHR	DL,CL
	CODER	JNZ,	WDL
	POP	AX
	POP	SI
	CMP	AL,80H
	CODER	JC,	WDB
	LODSW
	CODER	JMP,	WDW
CODE_WDB:	CMP	AL,40H
	CODER	JC,	WDX
	LODSB
	CBW
CODE_WDW:	TEST	AX,AX
	CODER	JZ,	WDX
	CODER	JNS,	WDM
	DEC	DI
CODE_WDM:
	CODER	CALL,	WHAS
	MOV	AL,5DH
	STOSB
	RET
CODE_WDX:	DEC	DI
	MOV	AL,5DH
	STOSB
	RET
FABS_SINGD:
CODE_SINGD:	DEC	DI
	RET
FABS_SPREFD:
CODE_SPREFD:
	CODER	CALL,	PSRD
	MOV	AL,3AH
	STOSB
	RET
FABS_ACCID:
CODE_ACCID:	XOR	AL,AL
	CODER	CALL,	WREG
	CODER	JMP,	G03DT
FABS_PSRD:
CODE_PSRD:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
CODE_WSR:
	SHR	AL,2
	AND	AX,6
	ADD	AX,REGS+20H
	XCHG	AX,SI
	CLD
	MOVSW
	XCHG	AX,SI
	RET
FABS_MSD:
CODE_MSD:	MOV	AL,10H
	MOV	EA32_VAR_PLUS(WADJ,0),AL
	LODSB
	PUSHW	AX
	CODER	CALL,	WDISP
	MOV	AL,2CH
	STOSB
	POP	AX
	CODER	JMP,	WSR  ; Tail call.
FABS_SMD:
CODE_SMD:	MOV	AL,10H
	MOV	EA32_VAR_PLUS(WADJ,0),AL
	LODSB
	PUSHW	AX
	CODER	CALL,	WSR
	MOV	AL,2CH
	STOSB
	POP	AX
	CODER	JMP,	WDISP  ; Tail call.
FABS_ACCRD:
CODE_ACCRD:	MOV	AX,EA32_VAR_PLUS(REGS,10h)
	STOSW
	MOV	AL,2CH
	STOSB
FABS_REGWD:
CODE_REGWD:	MOV	AL,10H
	MOV	EA32_VAR_PLUS(WADJ,0),AL
	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	OR	AL,0C0H
	CODER	JMP,	WDISP  ; Tail call.
FABS_RIMMD:
CODE_RIMMD:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	PUSHW	SI
	AND	AX,0FH
	SHL	AL,1
	PUSHW	AX
	ADD	AX,REGS
	MOV	SI,AX
	MOVSW
	POP	AX
	AND	AL,10H
	POP	SI
	MOV	EA32_VAR_PLUS(WADJ,0),AL
	CODER	JMP,	G03DT
FABS_RELWD:
CODE_RELWD:	LODSW
	ADD	AX,3
	ADD	AX,EA32_VAR_PLUS(PC,0)
	ADD	AX,EA32_VAR_PLUS(VORG,0)
	CODER	JMP,	WHA  ; Tail call.
;RELWD:	MOV	AX,2B24H
;	STOSW
;	LODSW
;	ADD	AX,3
;	JNS	RELWNM
;	DEC	DI
;RELWNM:
;	JMP	WHAS
FABS_AAMD:
CODE_AAMD:	LODSB
	CMP	AL,0AH
	CODER	JZ,	AAMD0
	XOR	AH,AH
	CODER	CALL,	WHA
CODE_AAMD0:	RET
FABS_ESCD:
CODE_ESCD:	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	MOV	AH,EA_SI_PLUS(0)
	MOV	CL,3
	ROR	AH,CL
	AND	AX,707H
	ROL	AL,CL
	OR	AL,AH
	XOR	AH,AH
	CODER	CALL,	WHA
	MOV	AL,2CH
	STOSB
	LODSB
	CODER	JMP,	WDISP  ; Tail call.
FABS_INTD:
CODE_INTD:	LODSB
	XOR	AH,AH
	CODER	JMP,	WHA  ; Tail call.
FABS_INT3D:
CODE_INT3D:	MOV	AL,33H
	STOSB
	RET
FABS_RETFD:
CODE_RETFD:	MOV	CL,0AH
	MOV	DX,D8086+2
	CODER	CALL,	WMN
	TEST	BYTE EA32_VAR_PLUS(OPCODE,0),1
	CODER	JZ,	RETD  ; Tail call.
	DEC	DI
	RET
FABS_RETD:
CODE_RETD:	LODSW
	CODER	JMP,	WHA  ; Tail call.
FABS_ADIOD:
CODE_ADIOD:	MOV	AX,EA32_VAR_PLUS(WADJ,0)
	ADD	AX,REGS
	PUSHW	SI
	MOV	SI,AX
	LODSW
	POP	SI
	MOV	DX,5844H
	TEST	BYTE EA32_VAR_PLUS(OPCODE,0),2
	CODER	JZ,	ADIOD0
	XCHG	AX,DX
CODE_ADIOD0:	STOSW
	MOV	AL,2CH
	STOSB
	XCHG	AX,DX
	STOSW
	RET
FABS_IBAPD:
CODE_IBAPD:	LODSB
	XOR	AH,AH
	CODER	CALL,	WHA
	MOV	AL,2CH
	STOSB
	MOV	AL,0C0H
	CODER	JMP,	WDISP  ; Tail call.
FABS_SEGOFD:
CODE_SEGOFD:	LODSW
	PUSHW	AX
	LODSW
	CODER	CALL,	WHA
	MOV	AL,3AH
	STOSB
	POP	AX
	CODER	JMP,	WHA  ; Tail call.
CODE_GRPD:	PUSHW	SI
	LODSB
	SHR	AL,3
	AND	AX,7
	PUSHW	AX
	MOV	SI,AX
	ADD	SI,CX
	MOV	CL,EA_SI_PLUS(0)
	MOV	DX,I8086+2
	CODER	CALL,	WMN
	MOV	AL,9
	STOSB
	POP	AX
	POP	SI
	RET
FABS_ACCMD:
CODE_ACCMD:	MOV	AL,6
	CODER	JMP,	RMD1
FABS_RWMD:
CODE_RWMD:	MOV	BYTE EA32_VAR_PLUS(WADJ,0),10H
FABS_RMD:
CODE_RMD:	LODSB
CODE_RMD1:	PUSHW	AX
	CODER	CALL,	WREG
	MOV	AL,2CH
	STOSB
	POP	AX
	CODER	JMP,	WDISP  ; Tail call.
FABS_G02D:
CODE_G02D:	MOV	CX,_G02D
	CODER	CALL,	GRPD
	CODER	CALL,	WPTR
	MOV	AL,2CH
	STOSB
	TEST	BYTE EA32_VAR_PLUS(OPCODE,0),2
	CODER	JZ,	G02D1
	MOV	AX,EA32_VAR_PLUS(REGS,2)
	STOSW
	RET
CODE_G02D1:	MOV	AL,31H
	STOSB
	RET
FABS_G03D:
CODE_G03D:	MOV	CX,_G03D
	CODER	CALL,	GRPD
	PUSHW	WORD EA_SI_PLUS(0)
	CODER	CALL,	WPTR
	POP	AX
	TEST	AL,30H
	CODER	JZ,	G03DT
	RET
FABS_G01D:
CODE_G01D:	MOV	CX,_G01D
	CODER	CALL,	GRPD
FABS_RMID:
CODE_RMID:
	CODER	CALL,	WPTR
CODE_G03DT:	MOV	AL,2CH
	STOSB
	LODSW
	TEST	BYTE EA32_VAR_PLUS(WADJ,0),0FFH
	CODER	JZ,	G03DB
	CMP	BYTE EA32_VAR_PLUS(OPCODE,0),83H
	CODER	JNZ,	G03DW
CODE_G03DB:	CBW
	DEC	SI
CODE_G03DW:
	CODER	JMP,	WHA  ; Tail call.
FABS_G04D:
CODE_G04D:	MOV	CX,_G04D
	CODER	CALL,	GRPD
	CMP	AL,7
	CODER	JZ,	INVD  ; Tail call.
	CMP	AL,5
	CODER	JZ,	G04DF
	CMP	AL,4
	CODER	JZ,	DISPD  ; Tail call.
	CMP	AL,3
	CODER	JZ,	G04DF
	CMP	AL,2
	CODER	JZ,	DISPD  ; Tail call.
	CODER	JMP,	WPTR  ; Tail call.
CODE_G04DF:	MOV	CL,0AH
	MOV	DX,D8086+2
	CODER	CALL,	WMN
FABS_DISPD:
CODE_DISPD:	LODSB
	CODER	JMP,	WDISP  ; Tail call.
FABS_INVD:
CODE_INVD:	MOV	AX,4244H
	STOSW
	MOV	AX,9
	STOSB
	MOV	AL,EA32_VAR_PLUS(OPCODE,0)
	CODER	JMP,	WHA  ; Tail call.

	;ASSERT_NONNEGATIVE -($-$$)+0x2000  ; File size (== code size) so far is at most 0x2000 bytes. This is to make sure it fits to the initally provisioned pages.

; --- DOS `int 31h' syscall implementations.
;
; The dossys* functions emulate the DOS `int 21h' syscall. The syscall
; number is in AH. Based on https://stanislavs.org/helppc/idx_interrupt.html

dossys_fatal:  ; Write 4 bytes at [esp] to stderr, and exit(1).
	push byte 4  ; SYS_write.
	pop eax
	xor ebx, ebx
	inc ebx
	inc ebx  ; STDERR_FILENO.
	mov ecx, esp
	mov edx, eax  ; Number of bytes to write: 4.
	int 80h  ; Linux i386 syscall.
	push 1  ; EXIT_FAILURE.
	; Fall through to dossys_exit.

dossys_exit:  ; Exit with exit code dword [esp].
	pop ebx  ; Ignore return address of dossys_exit.
	pop ebx  ; Exit code.
	xor eax, eax
	inc eax  ; SYS_exit.
	int 80h  ; Linux i386 syscall.
	; Not reached.

dossys_printmsg:  ; Print message at DX terminated by '$' to stdout.
	pushad
	pushf
	push byte 4  ; SYS_write.
	pop eax
	xor ebx, ebx
	inc ebx  ; STDOUT_FILENO.
	mov ecx, esi  ; Just for the high word.
	mov cx, dx
	or edx, -1
.next:	inc edx
	cmp byte [ecx+edx], '$'
	jne .next
	int 80h  ; Linux i386 syscall.
	popf
	popad
	ret

; Linux constants.
O_RDWR equ 2
O_CREAT equ 100o
O_TRUNC equ 1000o

badret:	popf
	popad
	stc
	ret

dossys_create:   ; Create file. CX is file attribute (ignored), DX points to the filename. Returns: CF indicating failure; AX (if CF=0) is the filehandle. We don't set the error code in AX.
	pushad
	pushf
	mov eax, 666o
	mov ecx, O_RDWR|O_CREAT|O_TRUNC
.both:	mov ebx, esi  ; Just for the high word.
	mov bx, dx
	xchg eax, edx  ; EDX := EAX; EAX := junk.
	push byte 5  ; SYS_open.
.cax:	pop eax
	int 80h  ; Linux i386 syscall.
	test eax, eax
	js badret  ; Treat any negative values as error. This effectively limits the usable file size to <2 GiB (7fffffffh bytes). That's fine, Linux won't give us more without O_LARGEFILE anyway.
	popf
	mov [esp+4*7], ax  ; So that `popad' will keep this in AX.
goodret:
	popad
	clc
	ret  ; This function doesn't work if open(...) returns file descriptor values larger than 0ffffh. That would be very rare.

dossys_open:   ; Open file. AL is access mode (0, 1 or 2). DX points to the filename. Returns: CF indicating failure; AX (if CF=0) is the filehandle. We don't set the error code in AX.
	pushad
	pushf
	mov ecx, eax
	and ecx, 3
	jmp dossys_create.both
	; Not reached.

dossys_close:  ; Close file. BX is the file descriptor to close. Returns: CF indicating failure. We don't set the error code in AX.
	pushad
	pushf
	push byte 6  ; SYS_close.
	pop eax
	int 80h  ; Linux i386 syscall.
	test eax, eax
	js badret  ; Treat any negative values as error. This effectively limits the usable file size to <2 GiB (7fffffffh bytes). That's fine, Linux won't give us more without O_LARGEFILE anyway.
	popf
	jmp goodret

dossys_read:   ; Read from file. BX is the file descriptor. CX is the number of bytes to read. DX is the data pointer. Returns: CF indicating failure; AX (if CF=0) is the number of bytes read. We don't set the error code in AX.
	pushad
	pushf
	push byte 3  ; SYS_read.
.do:	xchg edx, ecx
	or ecx, $$  ; Just for the high word.
	jmp dossys_create.cax
	; Not reached.

dossys_write:  ; Write to file. BX is the file descriptor. CX is the number of bytes to write. DX is the data pointer. Returns: CF indicating failure; AX (if CF=0) is the number of bytes written. We don't set the error code in AX. We don't support truncation on CX=0.
	jcxz .truncate
.write:	pushad
	pushf
	push byte 4  ; SYS_write.
	jmp dossys_read.do
	; Not reached.
.truncate:
	push dword '!TR'|10<<24  ; We don't implement truncation.
	jmp dossys_fatal
	; Not reached.

dossys_seek:   ; Seek in file. BX is the file descriptor. AL is whence (0 for SEEK_SET, 1 for SEEK_CUR, 2 for SEEK_END). CX is the high word of the offset. DX is the low word of the offset. Returns: CF indicating failure; AX (if CF=0) is the low word of the position; DX (if CF=0) is the high word of the position. We don't set the error code in AX. We don't support truncation on CX=0.
	pushad
	pushf
	shl ecx, 16
	mov cx, dx
	movzx edx, al
	push byte 19  ; SYS_lseek. (Only 32-bit offsets.)
	pop eax
	int 80h  ; Linux i386 syscall.
	test eax, eax
	js badret  ; Treat any negative values as error. This effectively limits the usable file size to <2 GiB (7fffffffh bytes). That's fine, Linux won't give us more without O_LARGEFILE anyway.
	popf
	mov [esp+4*7], ax  ; So that `popad' will keep this in AX.
	mov [esp+4*5], dx  ; So that `popad' will keep this in DX.
	jmp goodret


; --- .rodata and .data.

	EVEN
	;ASSERT_NONNEGATIVE ($-$$)-0x2000  ; File size (== code size) so far is at least 0x2000 bytes.
FUNCT_IHDL:  ; Function call table.
	DW	FABS_G0,FABS_G1,FABS_G2,FABS_G3
	DW	FABS_G4,FABS_G5,FABS_G6,FABS_G7
	DW	FABS_G8,FABS_G9,FABS_G0AH,FABS_G0BH
	DW	FABS_G0CH,FABS_G0DH,FABS_G0EH,FABS_G0FH
FUNCT_AHDL:  ; Function call table.
	DW	FABS_D0,FABS_SETEQU,FABS_SETEND
	DW	FABS_SETORG,FABS_SETDFB
	DW	FABS_D5,FABS_D6,FABS_SETINC
	DW	FABS_D8,FABS_D9
FUNCT_DHDL:  ; Function call table.
	DW	FABS_MRD,FABS_RMD,FABS_ACCID
	DW	FABS_PSRD,FABS_SPREFD,FABS_SINGD
	DW	FABS_REGWD,FABS_INVD,FABS_RELBD
	DW	FABS_G01D,FABS_G03D,FABS_G04D
	DW	FABS_MSD,FABS_SMD,FABS_DISPD
	DW	FABS_ACCRD,FABS_SEGOFD,FABS_ACCMD
	DW	FABS_MACCD,FABS_RIMMD,FABS_RETD
	DW	FABS_RWMD,FABS_RMID,FABS_RETFD
	DW	FABS_INT3D,FABS_INTD,FABS_G02D
	DW	FABS_AAMD,FABS_ESCD,FABS_IBAPD
	DW	FABS_RELWD,FABS_ADIOD
HDL86:	DB	0,0,1,1,2,2,3,3
	DB	0,0,1,1,2,2,3,3
	DB	0,0,1,1,2,2,3,3
	DB	0,0,1,1,2,2,3,3
	DB	0,0,1,1,2,2,4,5
	DB	0,0,1,1,2,2,4,5
	DB	0,0,1,1,2,2,4,5
	DB	0,0,1,1,2,2,4,5
	DB	6,6,6,6,6,6,6,6
	DB	6,6,6,6,6,6,6,6
	DB	6,6,6,6,6,6,6,6
	DB	6,6,6,6,6,6,6,6
	DB	7,7,7,7,7,7,7,7
	DB	7,7,7,7,7,7,7,7
	DB	8,8,8,8,8,8,8,8
	DB	8,8,8,8,8,8,8,8
	DB	9,9,9,9,1,1,1,1
	DB	0,0,1,1
	DB	0CH,01H,0DH,0EH
	DB	05H,0FH,0FH,0FH
	DB	0FH,0FH,0FH,0FH
	DB	05H,05H,10H,05H
	DB	05H,05H,05H,05H
	DB	11H,11H,12H,12H
	DB	05H,05H,05H,05H
	DB	02H,02H,05H,05H
	DB	05H,05H,05H,05H
	DB	13H,13H,13H,13H
	DB	13H,13H,13H,13H
	DB	13H,13H,13H,13H
	DB	13H,13H,13H,13H
	DB	07H,07H,14H,05H
	DB	15H,01H,16H,16H
	DB	07H,07H,17H,17H
	DB	18H,19H,05H,05H
	DB	1AH,1AH,1AH,1AH
	DB	1BH,1BH,05H,05H
	DB	1CH,1CH,1CH,1CH
	DB	1CH,1CH,1CH,1CH
	DB	08H,08H,08H,08H
	DB	02H,02H,1DH,1DH
	DB	1EH,1EH,10H,08H
	DB	1FH,1FH,1FH,1FH
	DB	05H,07H,05H,05H
	DB	05H,05H,0AH,0AH
	DB	05H,05H,05H,05H
	DB	05H,05H,0BH,0BH
BIN86:	DB	05H,05H,05H,05H
	DB	05H,05H,55H,53H
	DB	51H,51H,51H,51H
	DB	51H,51H,55H,53H
	DB	04H,04H,04H,04H
	DB	04H,04H,55H,53H
	DB	65H,65H,65H,65H
	DB	65H,65H,55H,53H
	DB	06H,06H,06H,06H
	DB	06H,06H,7FH,11H
	DB	6FH,6FH,6FH,6FH
	DB	6FH,6FH,7FH,12H
	DB	74H,74H,74H,74H
	DB	74H,74H,7FH,00H
	DB	0DH,0DH,0DH,0DH
	DB	0DH,0DH,7FH,03H
	DB	1AH,1AH,1AH,1AH
	DB	1AH,1AH,1AH,1AH
	DB	13H,13H,13H,13H
	DB	13H,13H,13H,13H
	DB	55H,55H,55H,55H
	DB	55H,55H,55H,55H
	DB	53H,53H,53H,53H
	DB	53H,53H,53H,53H
	DB	7FH,7FH,7FH,7FH
	DB	7FH,7FH,7FH,7FH
	DB	7FH,7FH,7FH,7FH
	DB	7FH,7FH,7FH,7FH
	DB	38H,34H,22H,2EH
	DB	3DH,37H,2CH,1EH
	DB	3CH,36H,39H,35H
	DB	27H,32H,30H,25H
	DB	7FH,7FH,7FH,7FH
	DB	70H,70H,72H,72H
	DB	4AH,4AH,4AH,4AH
	DB	4AH,40H,4AH,53H
	DB	4FH,72H,72H,72H
	DB	72H,72H,72H,72H
	DB	08H,10H,07H,71H
	DB	56H,54H,61H,3EH
	DB	4AH,4AH,4AH,4AH
	DB	4BH,4CH,0EH,0FH
	DB	70H,70H,6DH,6EH
	DB	43H,44H,66H,67H
	DB	4AH,4AH,4AH,4AH
	DB	4AH,4AH,4AH,4AH
	DB	4AH,4AH,4AH,4AH
	DB	4AH,4AH,4AH,4AH
	DB	7FH,7FH,5EH,5EH
	DB	41H,3FH,4AH,4AH
	DB	7FH,7FH,5EH,5EH
	DB	1BH,1BH,1CH,1DH
	DB	7FH,7FH,7FH,7FH
	DB	02H,01H,63H,73H
	DB	15H,15H,15H,15H
	DB	15H,15H,15H,15H
	DB	48H,49H,45H,23H
	DB	19H,19H,52H,52H
	DB	07H,29H,29H,29H
	DB	19H,19H,52H,52H
	DB	42H,7FH,5CH,5DH
	DB	16H,0CH,7FH,7FH
	DB	09H,6AH,0BH,6BH
	DB	0AH,6CH,7FH,7FH
_G01D:	DB	05H,51H,04H,65H
	DB	06H,6FH,74H,0DH
_G02D:	DB	5FH,60H,57H,58H
	DB	68H,69H,62H,64H
_G03D:	DB	60H,60H,50H,4EH
	DB	4FH,18H,14H,17H
_G04D:	DB	1AH,13H,07H,07H
	DB	29H,29H,55H,7FH
_DISP:	DB	0C6H,0E6H,0CAH,0EAH
	DB	0CH,0EH,0AH,6
RM:	DB	0EH,7,6,0FFH
	DB	5,1,3,0FFH
	DB	4,0,2,0FFH
	DB	0FFH,0FFH,0FFH,0FFH
REGS:	DB	"ALCLDLBLAHCHDHBH"
	DB	"AXCXDXBXSPBPSIDI"
	DB	"ESCSSSDS"
I8086:	DW	117
	DB	"AAA",0,37H,0
	DB	"AAD",0,0D5H,7
	DB	"AAM",0,0D4H,7
	DB	"AAS",0,3FH,0
	DB	"ADC",0,10H,1
	DB	"ADD",0,0,1
	DB	"AND",0,20H,1
	DB	"CALL",0,0,6
	DB	"CBW",0,98H,0
	DB	"CLC",0,0F8H,0
	DB	"CLD",0,0FCH,0
	DB	"CLI",0,0FAH,0
	DB	"CMC",0,0F5H,0
	DB	"CMP",0,38H,1
	DB	"CMPSB",0,0A6H,0
	DB	"CMPSW",0,0A7H,0
	DB	"CWD",0,99H,0
	DB	"DAA",0,27H,0
	DB	"DAS",0,2FH,0
	DB	"DEC",0,8,4
	DB	"DIV",0,30H,3
	DB	"ESC",0,0D8H,0EH
	DB	"HLT",0,0F4H,0
	DB	"IDIV",0,38H,3
	DB	"IMUL",0,28H,3
	DB	"IN",0,0E4H,0DH
	DB	"INC",0,0,4
	DB	"INT",0,0CDH,0CH
	DB	"INTO",0,0CEH,0
	DB	"IRET",0,0CFH,0
	DB	"JA",0,77H,5
	DB	"JAE",0,73H,5
	DB	"JB",0,72H,5
	DB	"JBE",0,76H,5
	DB	"JC",0,72H,5
	DB	"JCXZ",0,0E3H,5
	DB	"JE",0,74H,5
	DB	"JG",0,7FH,5
	DB	"JGE",0,7DH,5
	DB	"JL",0,7CH,5
	DB	"JLE",0,7EH,5
	DB	"JMP",0,1,6
	DB	"JNA",0,76H,5
	DB	"JNAE",0,72H,5
	DB	"JNB",0,73H,5
	DB	"JNBE",0,77H,5
	DB	"JNC",0,73H,5
	DB	"JNE",0,75H,5
	DB	"JNG",0,7EH,5
	DB	"JNGE",0,7CH,5
	DB	"JNL",0,7DH,5
	DB	"JNLE",0,7FH,5
	DB	"JNO",0,71H,5
	DB	"JNP",0,7BH,5
	DB	"JNS",0,79H,5
	DB	"JNZ",0,75H,5
	DB	"JO",0,70H,5
	DB	"JP",0,7AH,5
	DB	"JPE",0,7AH,5
	DB	"JPO",0,7BH,5
	DB	"JS",0,78H,5
	DB	"JZ",0,74H,5
	DB	"LAHF",0,9FH,0
	DB	"LDS",0,0C5H,8
	DB	"LEA",0,8DH,8
	DB	"LES",0,0C4H,8
	DB	"LOCK",0,0F0H,0AH
	DB	"LODSB",0,0ACH,0
	DB	"LODSW",0,0ADH,0
	DB	"LOOP",0,0E2H,5
	DB	"LOOPE",0,0E1H,5
	DB	"LOOPNE",0,0E0H,5
	DB	"LOOPNZ",0,0E0H,5
	DB	"LOOPZ",0,0E1H,5
	DB	"MOV",0,88H,9
	DB	"MOVSB",0,0A4H,0
	DB	"MOVSW",0,0A5H,0
	DB	"MUL",0,20H,3
	DB	"NEG",0,18H,3
	DB	"NOP",0,90H,0
	DB	"NOT",0,10H,3
	DB	"OR",0,8,1
	DB	"OUT",0,0E6H,0DH
	DB	"POP",0,38H,4
	DB	"POPF",0,9DH,0
	DB	"PUSH",0,30H,4
	DB	"PUSHF",0,9CH,0
	DB	"RCL",0,10H,2
	DB	"RCR",0,18H,2
	DB	"REP",0,0F3H,0AH
	DB	"REPE",0,0F3H,0AH
	DB	"REPNE",0,0F2H,0AH
	DB	"REPNZ",0,0F2H,0AH
	DB	"REPZ",0,0F3H,0AH
	DB	"RET",0,0C3H,0BH
	DB	"ROL",0,0,2
	DB	"ROR",0,8,2
	DB	"SAHF",0,9EH,0
	DB	"SAL",0,30H,2
	DB	"SALC",0,0D6H,0
	DB	"SAR",0,38H,2
	DB	"SBB",0,18H,1
	DB	"SCASB",0,0AEH,0
	DB	"SCASW",0,0AFH,0
	DB	"SHL",0,20H,2
	DB	"SHR",0,28H,2
	DB	"STC",0,0F9H,0
	DB	"STD",0,0FDH,0
	DB	"STI",0,0FBH,0
	DB	"STOSB",0,0AAH,0
	DB	"STOSW",0,0ABH,0
	DB	"SUB",0,28H,1
	DB	"TEST",0,0,3
	DB	"WAIT",0,9BH,0
	DB	"XCHG",0,86H,0FH
	DB	"XLATB",0,0D7H,0
	DB	"XOR",0,30H,1
D8086:	DW	23
	DB	"BYTE",0,1,5
	DB	"DB",0,1,4
	DB	"DD",0,4,4
	DB	"DS",0,0,6
	DB	"DW",0,2,4
	DB	"DWORD",0,3,5
	DB	"ECHO",0,0FCH,8
	DB	"END",0,0FFH,2
	DB	"EQU",0,0,1
	DB	"EVEN",0,90H,0
	DB	"FAR",0,0AH,5
	DB	"INCBIN",0,0FDH,7
	DB	"INCLUDE",0,0FEH,7
	DB	"HIGH",0,13H,5
	DB	"LOW",0,12H,5
	DB	"NEAR",0,9,5
	DB	"OFFSET",0,11H,5
	DB	"ORG",0,0,3
	DB	"PAGE",0,0FAH,9
	DB	"PTR",0,10H,5
	DB	"SHORT",0,8,5
	DB	"TITLE",0,0FBH,7
	DB	"WORD",0,2,5


;	Back to a72.nasm
ORIGIN:	DW	DEFORG
PAGLEN:	DW	DEFPAG
FUNCT_ADIR:  ; Function call table.
	DW	FABS_P2,FABS_P3,FABS_P4,FABS_P5,FABS_P6
EM0:	DB	"INVALID OPERAND",0
EM1:	DB	"SYNTAX ERROR",0
EM2:	DB	"INVALID ADDRESSING",0
EM3:	DB	"INVALID INSTRUCTION",0
EM4:	DB	"UNDEFINED SYMBOL",0
EM5:	DB	" BYTE(S) OUT OF RANGE",0
EM6:	DB	"OPERAND SIZE MISMATCH",0
EM7:	DB	"CONSTANT TOO LARGE",0
EM8:	DB	"MISSING OPERAND",0
EM9:	DB	"GARBAGE PAST END",0
EMA:	DB	"DUPLICATE SYMBOL",0
EMB:	DB	" NOT ACCESSIBLE",0
EMC:	DB	"RESERVED WORD MISUSE",0
EMD:	DB	"INVALID REGISTER",0
EME:	DB	"LINE TOO LONG",0
EMF:	DB	" FILE I/O ERROR",0
DOTASM:	DB	"asm",0
DOTCOM:	DB	"com",0
DOTLST:	DB	"lst",0
PASSM:	DB	"PASS ",0
INM:	DB	"IN: ",0
OUTM:	DB	"OUT: ",0
AMSG:	DB	"PC-72 ASSEMBLER"
	DB	" VERSION 1.05"
	DB	13,10,36
;DOSERR:	DB	"BAD DOS VERSION"
;	DB	13,10,36
NOPAR:	DB	"MISSING PARAMETER"
	DB	13,10,36
USAGE:	DB	"A72 IN [/SWITCH [OUT]"
	DB	" [/SWITCH [OUT]] ...]"
	DB	13,10
	DB	"/A [OUT[.com]]",9
	DB	"ASSEMBLE TO BINARY"
	DB	13,10
	DB	"/D [OUT[.asm]]",9
	DB	"DISASSEMBLE WITH HEX"
	DB	13,10
	DB	"/L [OUT[.lst]]",9
	DB	"ASSEMBLE TO LISTING"
	DB	13,10
	DB	"/O 100H",9,9
	DB	"SET ORIGIN"
	DB	13,10
	DB	"/U [OUT[.asm]]",9
	DB	"DISASSEMBLE PLAIN"
	DB	13,10,36

; --- .bss

prebss:
absolute $  ; Uninitialized data follows.
alignb 4
bss:

BUF1:	DS	MAXLEN
BUF2:	DS	100H
BUF3:	DS	100H
BUF4:	DS	100H
BUF5:	DS	100H
BUF6:	DS	100H
BUF7:	DS	100H
INCBUF:	DS	100H
SYMBS:
	DS 10000H-($-$$)-1  ; Temporary area in .bss for symbols. TODO(pts): Add bounds check. TODO(pts): Move the code (but not data) 12 KiB earlier to make it larger. TODO(pts): Make it larger (for that we'd need 32-bit address registers).
	vars  ; For NASM.

mem_end:
